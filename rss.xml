<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>devage@tistory</title>
<link>https://devage.tistory.com/</link>
<description></description>
<language>ko</language>
<pubDate>Tue, 27 Aug 2019 17:19:43 +0900</pubDate>
<generator>TISTORY</generator>
<managingEditor>devage</managingEditor>
<image>
<title>devage@tistory</title>
<url>http://cfile10.uf.tistory.com/image/2772B93D5819534B26774B</url>
<link>https://devage.tistory.com</link>
<description></description>
</image>
<item>
<title>deno 소개</title>
<link>https://devage.tistory.com/69</link>
<description>&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cy3Q0m/btqxJxmoo9C/4SutO6uMka6ZtPvoPkGNrK/img.png' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/cy3Q0m/btqxJxmoo9C/4SutO6uMka6ZtPvoPkGNrK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fcy3Q0m%2FbtqxJxmoo9C%2F4SutO6uMka6ZtPvoPkGNrK%2Fimg.png' width=&quot;100%&quot;&gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://deno.land&quot;&gt;deno&lt;/a&gt;는 node.js 제작자인 Ryan Dahl이 만든, typescript를 실행할 수 있는 server-side 런타임 엔진이다. node.js를 만들면서 이런 부분은 고쳤으면 좋겠다고 생각했던 점들을 반영했다고 한다.&lt;br /&gt;물론 javascript도 실행할 수 있다. 아래에 'Hello World'의 http server 버전 예제를 중심으로 node와 deno를 비교해보자.&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;&lt;code&gt;// node.js
var http = require(&quot;http&quot;);

http.createServer(function(req, res) {
  res.write(&quot;Hello World\n&quot;);
  res.end();
}).listen(8000, function() {
  console.log(&quot;http://localhost:8000/&quot;);
});&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;&lt;code&gt;// deno.js
import { http } from &quot;https://deno.land/std@v0.12/http/server.ts&quot;;

const body = new TextEncoder().encode(&quot;Hello World\n&quot;);
const s = http(&quot;:8000&quot;);

window.onload = async () =&amp;gt; {
  console.log(&quot;http://localhost:8000/&quot;);
  for await (const req of s) {
    req.respond({ body });
  }
};&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;대략 다음과 같이 세 가지 차이점이 눈에 띈다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;b&gt;module URL reference&lt;/b&gt;: npm과 같은 중앙 집중형 패키지 관리자 대신 분산 기반으로 모듈을 호출한다. node에서는 npm 중앙서버로부터 외부 패키지를 가져와 &lt;code&gt;node_modules/&lt;/code&gt; 밑에 설치하여 사용하였다. 반면 deno에서는 위 코드에서 보는 바와 같이 코드 위치를 URL로 지정하면 실행 단계에서 자동으로 모듈을 다운로드하여 설치한다. 또한 모듈 시스템으로 ES 모듈만 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;callback function vs. Promise (&lt;code&gt;async&lt;/code&gt;, &lt;code&gt;await&lt;/code&gt;)&lt;/b&gt;: node.js 초기에는 callback 함수를 사용했지만 다들 아시다시피 callback 함수 지옥은 악명이 높았다. Javascript에 Promise가 도입되면서 node.js에서도 callback 함수 대신 &lt;code&gt;async&lt;/code&gt;, &lt;code&gt;await&lt;/code&gt;를 사용할 수 있었다. deno에서는 처음부터 Promise를 활용한다.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;browser compatibility (&lt;code&gt;window&lt;/code&gt;)&lt;/b&gt;: server-side에서 실행하던 코드를 추가 수정 없이 브라우저에서 실행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 컴퓨팅 자원 접근에 대한 보안이 강화되어 I/O, networking 접근 시 접근 권한을 확인하는 질의를 런타임 시에 볼 수 있다. 물론 실행 시 command line 파라미터로 사전에 지정해줄도 수 있다.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;&lt;code&gt;$ deno deno.js 
️⚠️  Deno requests network access to &quot;:8000&quot;. Grant? [a/y/n/d (a = allow always, y = allow once, n = deny once, d = deny always)] y
http://localhost:8000/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;내부적으로 node.js와 같이 V8 javascript 엔진을 사용하고 있고, 그 외 부분은 C++ 대신 Rust를 이용하여 구현하고 있어서 비동기 스케줄러도 Rust로 작성한 tokio를 사용하고 있다.&lt;/p&gt;
&lt;p&gt;node.js 대비 초기 시작 속도는 약 3배 정도 빠르지만, I/O 쪽은 아직 개선의 여지가 있다고 한다. 이 부분만 개선되면 올해 내로 1.0 버전을 내놓을 계획이라고 한다.&lt;/p&gt;</description>
<category>기술</category>
<category>deno</category>
<category>JavaScript</category>
<category>node.js</category>
<category>rust</category>
<category>typescript</category>
<author>devage</author>
<guid>https://devage.tistory.com/69</guid>
<comments>https://devage.tistory.com/69#entry69comment</comments>
<pubDate>Tue, 27 Aug 2019 16:49:01 +0900</pubDate>
</item>
<item>
<title>Clark-Wilson model</title>
<link>https://devage.tistory.com/68</link>
<description>&lt;h3&gt;1. 정의&lt;/h3&gt;
&lt;p&gt;상업적&amp;nbsp;환경에 적합하도록 설계된 무결성 기반 접근 통제 모델&lt;/p&gt;
&lt;h3&gt;2. 개념도 및 구성 요소&lt;/h3&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/o9i1g/btqxMscav5Q/0OHI2CHm7UiWkcsTUJx9eK/img.png' data-lightbox='lightbox' data-alt='Clark-Wilson model'&gt;&lt;img src='https://k.kakaocdn.net/dn/o9i1g/btqxMscav5Q/0OHI2CHm7UiWkcsTUJx9eK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fo9i1g%2FbtqxMscav5Q%2F0OHI2CHm7UiWkcsTUJx9eK%2Fimg.png' data-filename=&quot;clark-wilson.png&quot; width=&quot;478&quot; height=&quot;243&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Clark-Wilson model&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 95px;&quot; border=&quot;1&quot; data-ke-style=&quot;style3&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;구성 요소&lt;/td&gt;
&lt;td style=&quot;width: 70%; height: 19px;&quot;&gt;설명&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;CDI (constrained data item)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 70%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;무결성이 보장되어야 할 데이터 항목. TP에 의해서만 조작되어야 함&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;UDI (unconstrained data item)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 70%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;통제 영역 외의 데이터 항목. 기본 read/write 작업으로 조작 가능&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;IVP (integrity verification procedure)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 70%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;CDI의 무결성을 확인하는 절차&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;TP (transformation procedure)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 70%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;CDI의 무결성을 유지하면서 데이터 항목을 조작하는 절차&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;3. 특징&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;접근 요소: 주체, 프로그램, 객체
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;주체는 객체에 직접 접근하지 못하며 프로그램에 의해서만 접근 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;감사를 필요로 하며, 프로그램에 대한 요청과 응답을 추적&lt;/li&gt;
&lt;li&gt;세 가지 무결성 규칙
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;인가되지 않은 사용자에 의한 수정 방지&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;background-color: #ff9a85;&quot;&gt;직무 분리로 내부 일관성과 외부 일관성 유지&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;인가된 사용자에 의한 부적절한 수정 방지&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 참고&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Clark%E2%80%93Wilson_model&quot;&gt;wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://slideplayer.com/slide/677490&quot;&gt;slideplayer 자료&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;타 블로그 요약 자료 - &lt;a href=&quot;https://finewink.tistory.com/m/229?category=769447&quot;&gt;#1&lt;/a&gt;, &lt;a href=&quot;https://m.blog.naver.com/sujunghan726/220315130644&quot;&gt;#2&lt;/a&gt;, &lt;a href=&quot;https://m.blog.naver.com/s2kiess/220482137886&quot;&gt;#3&lt;/a&gt;, &lt;a href=&quot;https://blog.naver.com/sdug12051205/221575582613&quot;&gt;#4&lt;/a&gt;, &lt;a href=&quot;https://m.blog.naver.com/nologout/220958111902&quot;&gt;#5&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<category>보안</category>
<category>Clark-Wilson</category>
<category>기술사</category>
<category>무결성</category>
<category>보안</category>
<category>접근통제</category>
<author>devage</author>
<guid>https://devage.tistory.com/68</guid>
<comments>https://devage.tistory.com/68#entry68comment</comments>
<pubDate>Mon, 26 Aug 2019 18:18:55 +0900</pubDate>
</item>
<item>
<title>Biba Model</title>
<link>https://devage.tistory.com/67</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2019.08.25 1차 작성&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1. 정의&lt;/h3&gt;
&lt;p&gt;주체 및 객체에 무결성 등급 부여가 가능한 무결성 제약 조건 보장 모델&lt;/p&gt;
&lt;h3&gt;2. Biba Model 개념도 및 속성&lt;/h3&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/mcbC5/btqxHBhVH4R/MCMLIMnKs4F673PkHl5PXK/img.png' data-lightbox='lightbox' data-alt='Biba Model'&gt;&lt;img src='https://k.kakaocdn.net/dn/mcbC5/btqxHBhVH4R/MCMLIMnKs4F673PkHl5PXK/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FmcbC5%2FbtqxHBhVH4R%2FMCMLIMnKs4F673PkHl5PXK%2Fimg.png' data-filename=&quot;biba.png&quot; width=&quot;329&quot; height=&quot;218&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Biba Model&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%;&quot; border=&quot;1&quot; data-ke-style=&quot;style3&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 40%;&quot;&gt;속성&lt;/td&gt;
&lt;td style=&quot;width: 60%;&quot;&gt;주요 내용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 40%;&quot;&gt;Simple Integrity property&lt;/td&gt;
&lt;td style=&quot;width: 60%;&quot;&gt;No read down. 무결성 등급이 높은 주체는 낮은 등급의 데이터를 읽을 수 없음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 40%;&quot;&gt;Integrity * - property&lt;/td&gt;
&lt;td style=&quot;width: 60%;&quot;&gt;No write up. 무결성 등급이 낮은 주체는 높은 등급의 데이터를 쓸 수 없음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 40%;&quot;&gt;Invocation property&lt;/td&gt;
&lt;td style=&quot;width: 60%;&quot;&gt;주체는 자신보다 무결성 등급이 높은 주체에게 서비스를 요청 (invoke)할 수 없음&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;3. 특징&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Bell-LaPadula model의 reverse 모델로, BLP에서 낮은 보안 등급의 주체에 의해 데이터가 overwrite되어 무결성이 깨지는 문제 해결&lt;/li&gt;
&lt;li&gt;기밀성 대신 무결성 (integrity)에 초점을 둔 모델로, Biba Integrity Model이라고도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 참고&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Biba_Model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Biba model from wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<category>보안</category>
<category>BIBA</category>
<category>기술사</category>
<category>무결성</category>
<category>보안</category>
<category>접근통제</category>
<author>devage</author>
<guid>https://devage.tistory.com/67</guid>
<comments>https://devage.tistory.com/67#entry67comment</comments>
<pubDate>Sun, 25 Aug 2019 10:58:37 +0900</pubDate>
</item>
<item>
<title>Bell-LaPadula (BLP) Model</title>
<link>https://devage.tistory.com/66</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2019.08.25 1차 수정 (참고 링크 추가)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1. 정의&lt;/h3&gt;
&lt;p&gt;정부 및 군용 응용 시스템의 접근 제어를 위해 Bell과 Lapadula에 의해 제안된 접근 통제 모델&lt;/p&gt;
&lt;h3&gt;2. Bell-LaPadula 모델의 개념도 및 주요 속성&lt;/h3&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cSCqyP/btqxHSDKCDZ/PquVEM0ju50yBTBKQQRt2k/img.png' data-lightbox='lightbox' data-alt='Bell-LaPadula Model 개념도'&gt;&lt;img src='https://k.kakaocdn.net/dn/cSCqyP/btqxHSDKCDZ/PquVEM0ju50yBTBKQQRt2k/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcSCqyP%2FbtqxHSDKCDZ%2FPquVEM0ju50yBTBKQQRt2k%2Fimg.png' data-filename=&quot;blp.png&quot; width=&quot;336&quot; height=&quot;225&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Bell-LaPadula Model 개념도&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%;&quot; border=&quot;1&quot; data-ke-style=&quot;style3&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 40%;&quot;&gt;속성&lt;/td&gt;
&lt;td style=&quot;width: 60%;&quot;&gt;주요 내용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 40%;&quot;&gt;단순 보안 속성 (simple security rule)&lt;/td&gt;
&lt;td style=&quot;width: 60%;&quot;&gt;상향 읽기 금지 (no-read-up)&lt;br /&gt;주어진 보안 수준에 위치하는 주체는 보다 높은 수준에 있는 데이터를 읽을 수 없음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 40%;&quot;&gt;*-속성 (star property)&lt;/td&gt;
&lt;td style=&quot;width: 60%;&quot;&gt;하향 쓰기 금지 (no-write-down)&lt;br /&gt;주어진 보안 수준에 위치하는 주체는 보다 낮은 수준으로 데이터를 쓸 수 없음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;width: 40%;&quot;&gt;임의 보안 속성 (discretionary security property)&lt;/td&gt;
&lt;td style=&quot;width: 60%;&quot;&gt;DAC를 명시하기 위해 access matrix 사용&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;strong star property
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;동일 수준 쓰기 (write-to-same): 주어진 보안 수준에 위치한 주체는 동일 수준에서만 데이터를 쓸 수 있음&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;color: #333333;&quot;&gt;*-속성의 대체&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 특징&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;비밀 정보가 허가되지 않는 방식으로 접근되는 것을 방지&lt;/li&gt;
&lt;li&gt;기밀성 (confidentiality) 강조 (무결성 (integrity) 용도가 아님)&lt;/li&gt;
&lt;li&gt;강제 접근 통제 방식 (MAC)의 근간이 되는 모델&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 문제점 및 해결 방안&lt;/h3&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 76px;&quot; border=&quot;1&quot; data-ke-style=&quot;style3&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 19px;&quot;&gt;구분&lt;/td&gt;
&lt;td style=&quot;width: 40%; height: 19px;&quot;&gt;내용&lt;/td&gt;
&lt;td style=&quot;width: 40%; height: 19px;&quot;&gt;해결 방안&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 19px;&quot;&gt;trusted subject&lt;/td&gt;
&lt;td style=&quot;width: 40%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;예외로 주요 규칙에 강제되지 않는 신뢰 주체 (trusted subject)에 의해 보안 정책 우회 가능&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 40%; height: 19px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;정보 흐름 모델 (model for information flow) 적용: 높은 보안 수준을 가진 정보가 낮은 보안 수준을 지닌 곳으로 전이하지 않도록 함&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 38px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 38px;&quot;&gt;blind write&lt;/td&gt;
&lt;td style=&quot;width: 40%; height: 38px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;하위 수준의 주체가 상위 수준의 주체가 write한 내용을 overwrite할 수 있음&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 40%; height: 38px;&quot;&gt;&lt;span style=&quot;color: #333333;&quot;&gt;주체의 취급 인가와 객체의 기밀 등급이 같을 때에만 write 허용 (Biba 모델)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;5. 참고&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;span style=&quot;letter-spacing: 0px;&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bell%E2%80%93LaPadula_model&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bell-LaPadula model from wikipedia&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<category>보안</category>
<category>Bell-LaPadula</category>
<category>기술사</category>
<category>보안</category>
<category>접근통제</category>
<author>devage</author>
<guid>https://devage.tistory.com/66</guid>
<comments>https://devage.tistory.com/66#entry66comment</comments>
<pubDate>Sun, 25 Aug 2019 07:46:43 +0900</pubDate>
</item>
<item>
<title>접근 통제 Access Control</title>
<link>https://devage.tistory.com/63</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2019.08.25 1차 작성&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1. 정의&lt;/h3&gt;
&lt;p&gt;사용자의 신원을 식별 또는 인증하여 대상 정보의 접근 및 사용 수준을 인가하는 절차 또는 메커니즘&lt;/p&gt;
&lt;h3&gt;2. 접근 통제의 개념도 및 요소&lt;/h3&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cKCmhZ/btqxHtqApEb/D0xQ3GkSBx6gPeL8lw3nEk/img.png' data-lightbox='lightbox' data-alt='접근 통제 개념도'&gt;&lt;img src='https://k.kakaocdn.net/dn/cKCmhZ/btqxHtqApEb/D0xQ3GkSBx6gPeL8lw3nEk/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcKCmhZ%2FbtqxHtqApEb%2FD0xQ3GkSBx6gPeL8lw3nEk%2Fimg.png' data-filename=&quot;access_control.png&quot; width=&quot;595&quot; height=&quot;128&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;접근 통제 개념도&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;- 위 정의에서 사용자는 주체, 대상 정보는 객체가 됨&lt;/p&gt;
&lt;h3&gt;3. 접근 통제 방식의 종류&lt;/h3&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 95px;&quot; border=&quot;1&quot; data-ke-style=&quot;style3&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 19px;&quot;&gt;&lt;b&gt;방식&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 80%; height: 19px;&quot;&gt;&lt;b&gt;종류&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 19px;&quot;&gt;패스워드 기반&lt;/td&gt;
&lt;td style=&quot;width: 80%; height: 19px;&quot;&gt;인식 패스워드, passphrase, PAP, CHAP, EAP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 19px;&quot;&gt;모델 기반&lt;/td&gt;
&lt;td style=&quot;width: 80%; height: 19px;&quot;&gt;MAC, MLS (MAC의 일종), DAC, RBAC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 19px;&quot;&gt;중앙 집중식&lt;/td&gt;
&lt;td style=&quot;width: 80%; height: 19px;&quot;&gt;AAA, DIAMETER, RADIUS, TACACS+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 20%; height: 19px;&quot;&gt;물리 기반&lt;/td&gt;
&lt;td style=&quot;width: 80%; height: 19px;&quot;&gt;출입카드, 담장, CCTV, 경비원&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;4. DAC (Discretionary Access Control) - 임의적 접근 통제&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;정의: 주체 또는 주체의 그룹의 신원에 근거하여 객체에 대한 접근을 통제하는 방법&lt;/li&gt;
&lt;li&gt;특징: ID 기반의 접근 통제 (ID 도용 우려)&lt;/li&gt;
&lt;li&gt;방법:&lt;br /&gt;
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;CL (capability list): 주체 별로 접근 가능한 객체와 그 접근 방식을 명시한 목록&lt;/li&gt;
&lt;li&gt;ACL (access control list): 객체 별로 접근 허가된 주체와 그 주체에 허가된 접근 방식을 명시한 목록&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;unix 파일 시스템 접근 권한&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5. MAC (Mandatory Access Control) - 강제적 접근 통제&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;정의: 객체에게 부과된 보안 레벨과 주체의 접근 허가를 기반으로 접근 통제하는 방법&lt;/li&gt;
&lt;li&gt;특징: 엄격한 접근 통제 관리, 객체의 소유자(owner)도 접근 권한 설정 불가&lt;/li&gt;
&lt;li&gt;방법:
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;보안등급 설정: 조직에 속한 자원의 중요도에 따라 설정 (unclassified(0), confident(1), secret(2), top secret(3))&lt;/li&gt;
&lt;li&gt;다단계 정책 (multi-level policy)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;주로 정부/군사용으로 사용, Bell-Lapadula 모델, Biba 모델&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;6. RBAC (Role-Based Access Control) - 역할기반 접근 통제&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;정의: 사용자 대신 역할에 따라 자원에 대한 접근을 통제하는 방법&lt;/li&gt;
&lt;li&gt;특징: 중앙관리자가 조직 내 주체와 객체의 상호관계를 통제, 계층적 역할 분배, 권한 관리 용이&lt;/li&gt;
&lt;li&gt;방법 (원리):
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;최소 권한 원칙: 역할 계층을 이용하여 작업에 꼭 필요한 최소한의 허가 사항만 역할에 배정&lt;/li&gt;
&lt;li&gt;직무 분리: 정보 무결성을 침해할 수 있는 작업은 상호 감시가 가능하도록 역할을 분리 수행&lt;/li&gt;
&lt;li&gt;&lt;span style=&quot;background-color: #ff9a85;&quot;&gt;데이터 추상화&lt;/span&gt;: 역할에 따라 이해 가능한 명령어로 추상화
&lt;ul style=&quot;list-style-type: disc;&quot;&gt;
&lt;li&gt;e.g. read/write/execute -&amp;gt; create(입금)/debit(출금)/transfer(이체)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;주로 기업에서 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;7. DAC, MAC, RBAC 비교&lt;/h3&gt;
&lt;table style=&quot;border-collapse: collapse; width: 100%; height: 133px;&quot; border=&quot;1&quot; data-ke-style=&quot;style3&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 10%; height: 19px;&quot;&gt;&lt;b&gt;구분&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;&lt;b&gt;DAC&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;&lt;b&gt;MAC&lt;/b&gt;&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;&lt;b&gt;RBAC&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 10%; height: 19px;&quot;&gt;특징&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;객체 중심 통제&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;강제적 통제&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;그룹/역할 단위 통제&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 10%; height: 19px;&quot;&gt;통제기반&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;신분 기반 (identity-based)&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;규칙 기반 (rule-based)&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;역할 기반 (role-based)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 10%; height: 19px;&quot;&gt;통제주체&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;객체 소유자&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;시스템&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;관리자&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 10%; height: 19px;&quot;&gt;핵심요소&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;CL,&amp;nbsp;&lt;span style=&quot;color: #333333;&quot;&gt;ACL&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;보안등급, 접근 인가&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;역할 (role), 그룹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 10%; height: 19px;&quot;&gt;장점&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;구현 용이, 유연성&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;보안성 우수&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;구성 변경 용이&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 10%; height: 19px;&quot;&gt;활용&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;대부분의 OS&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;군, 정부&lt;/td&gt;
&lt;td style=&quot;width: 30%; height: 19px;&quot;&gt;조직, 기업, ERP 등&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
<category>보안</category>
<category>DAC</category>
<category>Mac</category>
<category>RBAC</category>
<category>기술사</category>
<category>보안</category>
<category>접근통제</category>
<author>devage</author>
<guid>https://devage.tistory.com/63</guid>
<comments>https://devage.tistory.com/63#entry63comment</comments>
<pubDate>Sun, 25 Aug 2019 06:06:54 +0900</pubDate>
</item>
<item>
<title>SICP 연습문제 풀이 일부</title>
<link>https://devage.tistory.com/61</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;(2013년도에 SICP 스터디를 하면서 풀었던 연습문제 일부를 취합하여 올립니다)&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Exercise 1.3&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;세 숫자를 인자로 받아 그 가운데 큰 숫자 두 개를 제곱한 다음, 그 두 값을 덧셈하여 내놓는 프로시저를 정의하라.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;sort 함수 없이 가장 간단한 버전&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn ex-1-3  [a b c]
  (if  (and  (&amp;gt; a b)  (&amp;gt; b c))
    (+  (* a a)  (* b b))
    (if  (and  (&amp;gt; a b)  (&amp;gt; c b))
      (+  (* a a)  (* c c))
      (if  (and  (&amp;gt; a c)  (&amp;gt; b c))
        (+  (* a a)  (* b b))
        (+  (* b b)  (* c c))))))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;sort 함수를 사용한 버전&lt;/p&gt;
&lt;pre class=&quot;scheme&quot;&gt;&lt;code&gt;(defn ex-1-3 [a b c]
  (let [[x y] (sort &amp;gt; [a b c])]
    (+ (* x x) (* y y))))&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Exercise 1.8&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;세제곱근 (cube root)을 구하는 뉴튼 법은, x의 세제곱근에 가까운 값을 y라고 할 때 다음 식에 따라 y보다 더 가까운 값을 계산하는 것이다.&lt;br /&gt;&lt;code&gt;(x + y^2 + 2y) / 3&lt;/code&gt;&lt;br /&gt;제곱근 프로시저 처럼, 이 식을 써서 세제곱근 프로시저를 짜보자.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이미 앞에서 제곱근 구하는 코드를 짰기 때문에 필요한 부분만 수정하여 사용하면 된다.&lt;/p&gt;
&lt;pre class=&quot;scheme&quot;&gt;&lt;code&gt;(defn myabs [x]
  (if (&amp;lt; x 0) (- x) x))

(defn cube [x]
  (* x x x))

(defn good-enough? [guess x]
  (&amp;lt; (myabs (- (cube guess) x)) 0.001))

(defn improve [guess x]
  (/ (+ x (square guess) (* 2 guess)) 3))

(defn cubert-iter [guess x]
  (if (good-enough? guess x)
    guess
    (cubert-iter (improve guess x) x)))

(defn cubert [x]
  (cubert-iter 1.0 x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러나 실행하면, &lt;code&gt;StackOverflowError&lt;/code&gt; 가 발생한다. 검색 결과, 위 문제에 중요한 오타가 있다. 정확한 식은 &lt;code&gt;(x / y^2 + 2y) / 3&lt;/code&gt; 가 된다. 이에 따라 &lt;code&gt;improve&lt;/code&gt; 함수를 고쳐 쓴다.&lt;/p&gt;
&lt;pre class=&quot;scheme&quot;&gt;&lt;code&gt;(defn improve [guess x]
  (/ (+ (/ x (square guess)) (* 2 guess)) 3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다시 돌려보면 정상 실행 확인할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;excel&quot;&gt;&lt;code&gt;=&amp;gt; (cubert 8)
(cubert 8)
2.000004911675504
=&amp;gt; (cubert 27)
(cubert 27)
3.0000005410641766
=&amp;gt; (cubert 64)
(cubert 64)
4.000017449510739&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Exercise 1.11&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;n &amp;lt; 3 일 때 &lt;code&gt;f(n) = n&lt;/code&gt; 이고, n &amp;gt;= 3 일 때 &lt;code&gt;f(n) = f(n-1) + 2f(n-2) + 3f(n-3)&lt;/code&gt; 으로 정의한 함수 &lt;code&gt;f&lt;/code&gt;가 있다. &lt;code&gt;f&lt;/code&gt;의 프로시저를 되도는 프로세스recursive process가 나오도록 짜라. 아울러, 반복 프로세스를 만들어 내는 프로시저도 만들어 보라.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;먼저, 다음과 같이 scheme으로 재귀함수를 작성할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;scheme&quot;&gt;&lt;code&gt;(define (f-recur n)
  (cond ((= n 0) 0)
        ((&amp;lt; n 3)  (+ 1  (f-recur  (- n 1))))
        (else  (+
                (f-recur  (- n 1))
                (* 2  (f-recur  (- n 2)))
                (* 3  (f-recur  (- n 3)))))))
(define (f n)
  (f-recur n))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;clojure로는 다음과 같이 1:1로 변환할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn f-recur  [n]
  (cond
    (= n 0) 0
    (&amp;lt; n 3)  (+ 1  (f-recur  (- n 1)))
    :else  (+
            (f-recur  (- n 1))
            (* 2  (f-recur  (- n 2)))
            (* 3  (f-recur  (- n 3))))))

(defn f  [n]
  (f-recur n))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음은 반복 버전 scheme 코드인데, 재귀 방식보다 더 성능이 좋지 않다.&lt;/p&gt;
&lt;pre class=&quot;scheme&quot;&gt;&lt;code&gt;(define (f-iter result cnt max-cnt)
  (if (&amp;gt; cnt max-cnt)
    result
    (f-iter (cond
              ((= cnt 0) 0)
              ((&amp;lt; cnt 3) (+ 1 (f-iter 0 0 (- cnt 1))))
              (else (+
                      (f-iter 0 0 (- cnt 1))
                      (* 2 (f-iter 0 0 (- cnt 2)))
                      (* 3 (f-iter 0 0 (- cnt 3)))))) ; result
            (+ cnt 1)
            max-cnt)))

(define (f n)
  (f-iter 0 0 n))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음은 clojure로 변환한 반복 버전. 역시 느리다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn f-iter [result cnt max-cnt]
  (if (&amp;gt; cnt max-cnt)
    result
    (f-iter
      (cond
        (= cnt 0) 0
        (&amp;lt; cnt 3) (+ 1 (f-iter 0 0 (- cnt 1)))
        :else  (+
                (f-iter 0 0 (- cnt 1))
                (* 2 (f-iter 0 0 (- cnt 2)))
                (* 3 (f-iter 0 0 (- cnt 3))))) ; result
      (inc cnt)
      max-cnt)))

(defn f [n]
  (f-iter 0 0 n))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;일단 이렇게 작성해놓고 나서 다른 사람들은 어떻게 작성했나 검색을 해봤더니, &lt;code&gt;n &amp;lt; 3&lt;/code&gt; 인 경우에는 대부분 그냥 간단하게 처리해버렸다. 내 경우에는 재귀로 처리할 수 있는 부분은 가급적 재귀로 처리하도록 했는데, 문제에서의 함수의 정의를 고려하면 다른 사람들이 작성한 것 처럼 간단하게 처리하는 쪽이 &lt;code&gt;f(n) = n&lt;/code&gt;이라는 정의와 1:1 연관이 되어 좀더 알아보기 쉬우면서 같은 동작을 하는 함수를 작성할 수 있을 것 같다.&lt;/p&gt;
&lt;p&gt;iteration 버전의 경우, 함수가 총 3개의 항으로 되어 있는데 반복할 때마다 각 항 별로 계산 값을 넘겨주어야 함수의 코드가 간단해지는 것 같다.&lt;/p&gt;
&lt;p&gt;다음은 수정한 함수들이다. 먼저 재귀 버전.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn f-recur [n]
  (if (&amp;lt; n 3)
    n
    (+ (f-recur (- n 1))
       (* 2 (f-recur (- n 2)))
        (* 3 (f-recur (- n 3))))))

(defn f [n]
  (f-recur n))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음은 반복 버전. 훨씬 간단해졌다. 실행해보니 overflow 전까지는 지연 없이 거뜬히 연산을 해낸다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn f-iter [s1 s2 s3 cnt]
  (if (&amp;lt; cnt 3)
    s1
    (f-iter (+ s1 (* 2 s2) (* 3 s3)) s1 s2 (dec cnt))))

(defn f [n]
  (if (&amp;lt; n 3)
    n
    (f-iter 2 1 0 n)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PS. 바로 위 반복 버전의 경우에는 인수를 다섯 개로 하거나 분량이 더 늘어나거나 하는 수정 삽질을 거치고 나니 코드를 수정하기 전에 잠깐 본 &lt;a href=&quot;http://stackoverflow.com/questions/2365993/no-idea-how-to-solve-sicp-exercise-1-11&quot;&gt;stackoverflow의 솔루션&lt;/a&gt;과 똑같아졌다.&lt;/p&gt;
&lt;p&gt;몇초 잠깐 봤을 뿐인 내용이 무의식 중에 뇌리에 박혀서 유도를 하는 것일까.&lt;/p&gt;
&lt;h2&gt;Exercise 1.12&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;다음은 파스칼의 세모꼴Pascal's triangle이다. 파스칼의 세모꼴 수를 만드는 프로시저를 짜되, 되도는 프로세스가 나오도록 하라.&lt;/p&gt;
&lt;pre class=&quot;lsl&quot;&gt;&lt;code&gt;        1
       1 1
      1 2 1
     1 3 3 1
    1 4 6 4 1
       ...&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;지금까지 본 다른 예제는 n번째의 특정 값을 구하는 것이었는데, 이번 예제는 n번째 수열을 구해야 한다. scheme으로는 (찾으려면 찾을 수도 있지만) 리스트를 만들어 반환하는 함수는 아직 배우지 못했으므로, 바로 clojure로 작성하기로 했다. 어떻게 재귀 함수의 형태로 작성할 것인지 이리저리 궁리한 후, 다음과 같이 정리할 수 있었다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ko.wikipedia.org/wiki/%ED%8C%8C%EC%8A%A4%EC%B9%BC%EC%9D%98_%EC%82%BC%EA%B0%81%ED%98%95&quot;&gt;위키피디아&lt;/a&gt; 의 내용을 참고하면, n번째 수열의 k번째 값 &lt;code&gt;P_nk&lt;/code&gt;는 다음과 같이 정의할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;lsl&quot;&gt;&lt;code&gt;    P_nk = P_(n-1)(k-1) + P_(n-1)k,
    P_n1 = P_nn = 1
      where n &amp;gt;= 1, 1 &amp;lt;= k &amp;lt;= n&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이에 따라 먼저, 1부터 n 번째까지 각 항의 파스칼의 삼각형 수를 구해 리스트에 더하는 함수를 짜고, 1과 n 사이의 k 번째 항의 파스칼의 삼각형 수를 구하는 함수는 재귀 함수로 작성을 했다. 작성한 코드는 다음과 같다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn pascal-triangle-recur [n k]
  (cond
    (= k n) 1
    (= k 1) 1
    :else (+
            (pascal-triangle-recur (dec n) (dec k))
            (pascal-triangle-recur (dec n) k))))

(defn pascal-triangle [n]
  (loop [result [] k n]
    (if (zero? k)
      result
      (recur (cons (pascal-triangle-recur n k) result) (dec k)))))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행 결과는 다음과 같다.&lt;/p&gt;
&lt;pre class=&quot;excel&quot;&gt;&lt;code&gt;=&amp;gt; (pascal-triangle 1)
(1)
=&amp;gt; (pascal-triangle 2)
(1 1)
=&amp;gt; (pascal-triangle 3)
(1 2 1)
=&amp;gt; (pascal-triangle 4)
(1 3 3 1)
=&amp;gt; (pascal-triangle 5)
(1 4 6 4 1)
=&amp;gt; (pascal-triangle 6)
(1 5 10 10 5 1)
=&amp;gt; (pascal-triangle 7)
(1 6 15 20 15 6 1)
=&amp;gt; (pascal-triangle 8)
(1 7 21 35 35 21 7 1)
=&amp;gt; (pascal-triangle 9)
(1 8 28 56 70 56 28 8 1)
=&amp;gt; (pascal-triangle 10)
(1 9 36 84 126 126 84 36 9 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PS. scheme으로는 어떻게 작성했는지 웹 검색으로 좀 컨닝을 해봤더니, 대부분 n번째 행 k번째의 파스칼의 삼각형 값을 구하거나 (즉, &lt;code&gt;(pascal-triangle-recur n k)&lt;/code&gt; 까지만 작성), 아니면 아예 1열부터 n열까지 구해서 삼각형 모양으로 출력하는 등 둘 중 하나를 따라서 했더군요.&lt;/p&gt;
&lt;h2&gt;Exercise 1.16&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fast-expt&lt;/code&gt;처럼 계산 시간이 로그 비례로 늘어나면서 반복 프로세스를 수행하는 거듭제곱 프로시저 작성하기&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn fast-expt [b n]
  (fast-expt-iter b 1 n))

(defn fast-expt-iter [b a n]
  (cond
    (= n 0) a
    (even? n) (fast-expt-iter (* b b) a (/ n 2))
    :else (fast-expt-iter b (* a b) (dec n))))&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Exercise 1.17&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;정수 값을 두 배로 하거나 반으로 나누는 프로시저가 있다고 가정하고, 이 프로시저를 써서 &lt;code&gt;fast-expt&lt;/code&gt; 처럼 계산 단계가 로그 비례로 자라나는 곱셈 프로시저를 작성하라.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;정수 값을 두 배 또는 반으로 만드는 프로시저는 다음과 같다.&lt;/p&gt;
&lt;pre class=&quot;scheme&quot;&gt;&lt;code&gt;(defn twice [a]
  (* a 2))

(defn halve [a]
  (/ a 2))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;재귀 버전을 작성하면 되는 것이므로 조금 더 쉽게 작성할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn fast-mul [a b]
  (cond (= b 0) 0
        (even? b) (twice (fast-mul a (halve b)))
        :else (+ a (fast-mul a (- b 1)))))&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Exercise 1.18&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;연습문제 1.16과 1.17에서 얻은 결과를 바탕으로, 계산 단계가 로그 비례로 자라나는 반복 프로세스가 되도록 곱셈 프로시저를 작성하라. (러시아 농사꾼 방식&lt;i&gt;Russian peasent method&lt;/i&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn twice [a]
  (* a 2))

(defn halve [a]
  (/ a 2))

(defn fast-mul-iter [a n p]
  (cond
   (= n 0) p
   (even? n) (fast-mul-iter (twice a) (halve n) p)
   :else     (fast-mul-iter a (dec n) (+ p a))))

(defn fast-mul [a b]
  (fast-mul-iter a b 0))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 이 짝수나 아니냐 조건 비교 다음에 함수를 호출해줄 때 어떻게 인수를 갱신하여 넣는가 하는 것이 관건.&lt;/p&gt;
&lt;h2&gt;Exercise 1.19&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;피보나치 수열을 구하는 계산 단계가 다음과 같이 로그 차수로 자라나는 코드로 작성할 수 있다. 여기서 &lt;code&gt;p = 0&lt;/code&gt;, &lt;code&gt;q = 1&lt;/code&gt;이면 피보나치 수열을 구하는 함수가 된다. 여기서, &lt;code&gt;(T_pq)^2 = T_p'q'&lt;/code&gt;임을 증명하고, p와 q로 p'와 q'를 계산하는 식을 구하라. 이는 아래 코드의 &lt;code&gt;update-p&lt;/code&gt;와 &lt;code&gt;update-q&lt;/code&gt; 함수의 내용이 될 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;scheme&quot;&gt;&lt;code&gt;(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (update-p p)      ; calc p'
                   (update-q q)      ; calc q'
                   (/ count 2)))
         (else (fib-iter (+ (* b q) (* a q) (* a p))
                         (+ (* b p) (* a q))
                         p
                         q
                         (- count 1)))))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;T_p'q' = (T_pq)^2&lt;/code&gt; 는 다음과 같이 정리할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;lsl&quot;&gt;&lt;code&gt;a &amp;lt;- bpq + aq^2 + bq^2 + aq^2 + apq + bpq + apq + ap^2
  &amp;lt;- 2(a+b)pq + (2a+b)q^2 + ap^2
   = bq' + aq' + ap'

b &amp;lt;- bp^2 + apq + bq^2 + aq^2 + apq
  &amp;lt;- 2apq + (a+b)q^2 + bp^2
   = bp' + aq'&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;윗 식을 정리하면, &lt;code&gt;p'&lt;/code&gt; 및 &lt;code&gt;q'&lt;/code&gt; 은 다음과 같이 구할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;lsl&quot;&gt;&lt;code&gt;p' = p^2 + q^2
q' = 2pq + q^2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이를 &lt;code&gt;update-p&lt;/code&gt; 및 &lt;code&gt;update-q&lt;/code&gt; 함수로 표현하고 전체 코드를 clojure로 다시 작성한 답은 다음과 같다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn update-p [p q]
  (+ (* p p) (* q q)))

(defn update-q [p q]
  (+ (* 2 p q) (* q q)))

(defn fib-iter [a b p q count]
  (cond
   (= count 0) b
   (even? count) (fib-iter a
                           b
                           (update-p p q)
                           (update-q p q)
                           (/ count 2))
   :else (fib-iter (+ (* b q) (* a q) (* a p))
                   (+ (* b p) (* a q))
                   p
                   q
                   (dec count))))

(defn fib [n]
  (fib-iter 1 0 0 1 n))&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>clojure</category>
<category>SICP</category>
<author>devage</author>
<guid>https://devage.tistory.com/61</guid>
<comments>https://devage.tistory.com/61#entry61comment</comments>
<pubDate>Fri, 23 Aug 2019 12:34:08 +0900</pubDate>
</item>
<item>
<title>사전 정의된 erlang 매크로들</title>
<link>https://devage.tistory.com/59</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.04.26에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;erlang에서는 C 언어의 &lt;code&gt;#define&lt;/code&gt;처럼 매크로를 정의해서 사용할 수 있다. 다음과 같이 정의한다.&lt;/p&gt;
&lt;pre class=&quot;puppet&quot;&gt;&lt;code&gt;-define(VAR, 10).
-define(Function(Arg1, Arg2), YourCodes).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그 후 원하는 곳에 &lt;code&gt;?VAR&lt;/code&gt;처럼 앞에 &lt;code&gt;?&lt;/code&gt;를 붙여 사용한다. 두 번째 함수 매크로의 경우 정의한 arg의 수를 맞춰서 사용해야 한다.&lt;/p&gt;
&lt;p&gt;위와 같이 &lt;code&gt;-define&lt;/code&gt;으로 따로 정의하지 않아도 erlang 내부적으로 정의되어 있는 매크로들이 있다. 다음은 사전 정의된 매크로들을 확인할 수 있는 예제 코드이다.&lt;/p&gt;
&lt;pre class=&quot;prolog&quot;&gt;&lt;code&gt;% macros.erl
-module(macros).
-export([print/0]).

print() -&amp;gt;
  io:format(&quot;?MODULE = ~p~n&quot;, [?MODULE]),
  io:format(&quot;?MODULE_STRING = ~p~n&quot;, [?MODULE_STRING]),
  io:format(&quot;?FILE = ~p~n&quot;, [?FILE]),
  io:format(&quot;?LINE = ~p~n&quot;, [?LINE]),
  io:format(&quot;?MACHINE = ~p~n&quot;, [?MACHINE]),
  io:format(&quot;?FUNCTION_NAME = ~p~n&quot;, [?FUNCTION_NAME]),
  io:format(&quot;?FUNCTION_ARITY = ~p~n&quot;, [?FUNCTION_ARITY]),
  ok.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행 결과는 다음과 같다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;Eshell V8.3  (abort with ^G)
1&amp;gt; macros:print().
?MODULE = macros
?MODULE_STRING = &quot;macros&quot;
?FILE = &quot;macros.erl&quot;
?LINE = 9
?MACHINE = 'BEAM'
?FUNCTION_NAME = print
?FUNCTION_ARITY = 0
ok&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;?MODULE&lt;/code&gt;, &lt;code&gt;?MACHINE&lt;/code&gt;, &lt;code&gt;?FUNCTION_NAME&lt;/code&gt;은 각각 모듈명, 머신 종류, 함수명을 atom 형식으로 치환한다. 오히려 문자열로 치환되는 &lt;code&gt;?FILE&lt;/code&gt;이 특이한 케이스이다. 모듈명의 경우 문자열로 치환해달라는 요구사항이 많았는지 &lt;code&gt;?MODULE_STRING&lt;/code&gt;이 따로 정의돼 있다. 마지막 &lt;code&gt;?FUNCTION_ARITY&lt;/code&gt;는 함수의 인자 수를 표현한다.&lt;/p&gt;</description>
<category>기술</category>
<category>Erlang</category>
<author>devage</author>
<guid>https://devage.tistory.com/59</guid>
<comments>https://devage.tistory.com/59#entry59comment</comments>
<pubDate>Thu, 22 Aug 2019 21:21:12 +0900</pubDate>
</item>
<item>
<title>Erlang으로 SSL 연결 만들어보기</title>
<link>https://devage.tistory.com/58</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.04.18에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SSL/TLS에 대해서는 그 배경 지식에 대해서 전문적으로 알고 있는 입장이 아니라서, 여기서는 간단하게 지난 번에 만들었던 cowboy 기반 웹소켓 서버 소스에 wss (secured websocket) 관련 코드를 추가하였다. 그리고 DTLS 연결 테스트도 해봤는데, Erlang/OTP 소스의 ssl 모듈에 있는 예제에 한 줄 추가하여 만들었다.&lt;/p&gt;
&lt;h2&gt;wss 연결 만들기&lt;/h2&gt;
&lt;p&gt;한 번 기본 웹소켓 서버 코드를 작성했다면 여기에 SSL 관련 코드를 추가하는 건 어렵지 않다. 먼저 &lt;code&gt;myapp.app.src&lt;/code&gt; 파일에서 시작 어플리케이션에 &lt;code&gt;ssl&lt;/code&gt;을 추가한다.&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;&lt;code&gt;   {applications,
    [kernel,
     stdlib,
-    cowboy
+    cowboy,
+    ssl
    ]},
   {env,[]},
   {modules, []},&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그 후 &lt;code&gt;myapp_app.erl&lt;/code&gt;에서 ws가 아닌 wss로 서버가 실행되도록 한다. 추가한 작업은 옵션에 인증서 파일 위치를 추가한 것과 &lt;code&gt;cowboy:start_clear/4&lt;/code&gt; 대신 &lt;code&gt;cowboy:start_tls/4&lt;/code&gt;를 사용한 것 뿐이다. 인증서는 self-signed 사설 인증서로, 직접 생성한 것은 아니고 cowboy 소스의 &lt;code&gt;examples/ssl_hello_world/&lt;/code&gt;에 있는 인증서를 그대로 사용했다. &lt;a href=&quot;https://github.com/ninenines/cowboy/tree/master/examples/ssl_hello_world/priv/ssl&quot;&gt;다음 위치&lt;/a&gt;에서 바로 받을 수 있으며, 프로젝트 디렉토리에 &lt;code&gt;priv/&lt;/code&gt; 디렉토리를 만들고 다시 &lt;code&gt;ssl/&lt;/code&gt; 하위 디렉토리를 만들어서 여기에 넣어주었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;priv/&lt;/code&gt; 디렉토리는 리소스 파일 등 어플리케이션 실행에 필요한 데이터 파일들을 담아두는 곳이다. &lt;code&gt;code:priv_dir/1&lt;/code&gt;은 이 디렉토리의 절대 경로 정보를 반환하는 함수이다. 빌드 후에는 빌드 결과물이 있는 위치로 리소스 파일들이 따라서 복사되기 때문에 사전에 정확한 경로를 알 수 없기 때문이다.&lt;/p&gt;
&lt;pre class=&quot;elm&quot;&gt;&lt;code&gt;     ]}],
   Dispatch = cowboy_router:compile(Routes),
   NAcceptors = 100,
-  TransOpts = [{ip, {0, 0, 0, 0}}, {port, 8080}],
+  PrivDir = code:priv_dir(myapp),
+   = [{ip, {0, 0, 0, 0}}, {port, 8080}
+               , {cacertfile, PrivDir ++ &quot;/ssl/cowboy-ca.crt&quot;}
+               , {certfile, PrivDir ++ &quot;/ssl/server.crt&quot;}
+               , {keyfile, PrivDir ++ &quot;/ssl/server.key&quot;}
+              ],
   ProtoOpts = #{env =&amp;gt; #{dispatch =&amp;gt; Dispatch}},
-  {ok, _} = cowboy:start_clear(http, NAcceptors, TransOpts, ProtoOpts),
+  {ok, _} = cowboy:start_tls(https, NAcceptors, TransOpts, ProtoOpts),
   wssvr_sup:start_link().&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;클라이언트 측도 수정한다. &lt;code&gt;ws_client.js&lt;/code&gt; 내의 웹소켓 url을 'ws'에서 'wss'로 바꾸는 작업 뿐이다.&lt;/p&gt;
&lt;pre class=&quot;haxe&quot;&gt;&lt;code&gt; var WebSocket = require('ws');
-var ws = new WebSocket('ws://localhost:8080/');
+var ws = new WebSocket('wss://localhost:8080/');

 ws.on('open', function open() {&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 곧바로 node로 실행하면 상대 서버가 self-signed 인증서를 사용했다는 메시지와 함께 오류 처리해버린다.&lt;/p&gt;
&lt;pre class=&quot;subunit&quot;&gt;&lt;code&gt;$ node ws_client.js 
error: Error: self signed certificate in certificate chain&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;디폴트로 self-signed 인증서 사용을 막았기 때문이다. 이 경우 &lt;code&gt;NODE_TLS_REJECT_UNAUTHORIZED&lt;/code&gt; 환경 변수와 함께 사용하면 된다.&lt;/p&gt;
&lt;pre class=&quot;crmsh&quot;&gt;&lt;code&gt;$ NODE_TLS_REJECT_UNAUTHORIZED=0 node ws_client.js&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;요즘은 letsencrypt를 이용한 인증서를 많이 사용하는 추세이다. 도메인만 갖고 있으면 무료로 만들 수 있어서 편하다. 여기서는 letsencrypt를 사용하는 방법은 건너뛴다. letsencrypt로 만든 인증서는 보통 &lt;code&gt;/etc/letsencrypt/live/(domain-name)/&lt;/code&gt;에 있는 것으로 사용할 수 있다. 이 디렉토리를 &lt;code&gt;priv/&lt;/code&gt; 디렉토리 밑에 &lt;code&gt;cert/&lt;/code&gt; 란 이름으로 symbolic link를 만들어 연결했다 (이름은 다른 것으로 바꿔도 된다). 그리고 위의 &lt;code&gt;myapp_app.erl&lt;/code&gt; 수정 내용 중 &lt;code&gt;TransOpts&lt;/code&gt; 변수의 인증서 설정만 다음과 같이 self-signed 사설 인증서에서 letsencrypt 인증서로 바꿨다.&lt;/p&gt;
&lt;pre class=&quot;xquery&quot;&gt;&lt;code&gt;   TransOpts = [{ip, {0, 0, 0, 0}}, {port, 8080}
-               , {cacertfile, PrivDir ++ &quot;/ssl/cowboy-ca.crt&quot;}
-               , {certfile, PrivDir ++ &quot;/ssl/server.crt&quot;}
-               , {keyfile, PrivDir ++ &quot;/ssl/server.key&quot;}
+               , {cacertfile, PrivDir ++ &quot;/cert/chain.pem&quot;}
+               , {certfile, PrivDir ++ &quot;/cert/cert.pem&quot;}
+               , {keyfile, PrivDir ++ &quot;/cert/privkey.pem&quot;}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 웹소켓 클라이언트에서 &lt;code&gt;NODE_TLS_REJECT_UNAUTHORIZED&lt;/code&gt; 환경 변수를 뺄 수 있다.&lt;/p&gt;
&lt;h2&gt;DTLS 연결 만들기&lt;/h2&gt;
&lt;p&gt;SSL 연결 관련한 코딩에는 경험이 없기도 했고, DTLS에 관해서는 문서화된 내용도 없기 때문에 (OTP 20부터 포함될 것이라고 한다) Erlang/OTP 소스의 ssl 모듈에 있는 &lt;code&gt;client_server.erl&lt;/code&gt; 예제를 이용해서 테스트를 했다. 이 예제는 다음과 같은 간단한 구성으로 loopback 인터페이스 상으로 TLS 연결을 하도록 되어 있다.&lt;/p&gt;
&lt;pre class=&quot;gherkin&quot;&gt;&lt;code&gt;     start/0
     +-------+
     |       |
     |       |
     +---+---+         init_connect/1
         |    (spawn)  +-------+
         +------------&amp;gt;+       |
         |             |       |
         |             +---+---+
         |                 |
         |                 |
         v    (connect)    v
ssl:listen/2 &amp;lt;========== ssl:connect/3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;기존의 TLS 연결 예제를 아래와 같이 수정하여 DTLS로 연결하도록 했다. &lt;code&gt;mk_opts/1&lt;/code&gt; 함수는 서버 측에서 호출하는 &lt;code&gt;ssl:listen/2&lt;/code&gt; 및 클라이언트 측 &lt;code&gt;ssl:connect/3&lt;/code&gt; 양쪽 함수에 파라미터로 전달될 옵션을 생성하는 함수이다. 이 함수를 통해서 &lt;code&gt;{protocol, dtls}&lt;/code&gt; 옵션을 더 추가하여 전달하게 된다.&lt;/p&gt;
&lt;pre class=&quot;tcl&quot;&gt;&lt;code&gt; mk_opts(Role) -&amp;gt;
     Dir = filename:join([code:lib_dir(ssl), &quot;examples&quot;, &quot;certs&quot;, &quot;etc&quot;]),
     [{active, false},
      {verify, 2},
      {depth, 2},
+     {protocol, dtls},
      {cacertfile, filename:join([Dir, Role, &quot;cacerts.pem&quot;])},
      {certfile, filename:join([Dir, Role, &quot;cert.pem&quot;])},
      {keyfile, filename:join([Dir, Role, &quot;key.pem&quot;])}].&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사실, 테스트 해보면 TLS로 연결될 때나 DTLS로 연결될 때나 터미널 상에 찍히는 로그 메시지로는 그 차이를 알기 어렵다. 이에 관해서는 tcpdump나 Wireshark 통해서 찍어보는 것이 제일 좋다. 다음은 Wireshark로 TLS 연결을 잡은 것이다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/b6vx3N/btqxGbwaDPZ/devWesd5tE3goQw335yxL1/img.png' data-lightbox='lightbox' data-alt='TLS 캡쳐'&gt;&lt;img src='https://k.kakaocdn.net/dn/b6vx3N/btqxGbwaDPZ/devWesd5tE3goQw335yxL1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fb6vx3N%2FbtqxGbwaDPZ%2FdevWesd5tE3goQw335yxL1%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;TLS 캡쳐&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;아래는 Wireshark로 DTLS 연결을 잡은 것이다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/d08reH/btqxEBWE5SD/FU7SWUG0menaBsTQiZeSu0/img.png' data-lightbox='lightbox' data-alt='DTLS 캡쳐'&gt;&lt;img src='https://k.kakaocdn.net/dn/d08reH/btqxEBWE5SD/FU7SWUG0menaBsTQiZeSu0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fd08reH%2FbtqxEBWE5SD%2FFU7SWUG0menaBsTQiZeSu0%2Fimg.png' &gt;&lt;/span&gt;&lt;figcaption&gt;DTLS 캡쳐&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description>
<category>기술</category>
<category>Cowboy</category>
<category>dtls</category>
<category>Erlang</category>
<category>tls</category>
<author>devage</author>
<guid>https://devage.tistory.com/58</guid>
<comments>https://devage.tistory.com/58#entry58comment</comments>
<pubDate>Thu, 22 Aug 2019 21:18:39 +0900</pubDate>
</item>
<item>
<title>erlang bit syntax에 대하여</title>
<link>https://devage.tistory.com/57</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.03.25에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;erlang에서는 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;와 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;로 감싸서 바이너리 데이터를 다루는데, &lt;code&gt;&amp;lt;&amp;lt;&quot;Hello World!&quot;&amp;gt;&amp;gt;&lt;/code&gt; 처럼 쓰면 C 언어에서의 &lt;code&gt;char *&lt;/code&gt; 문자열과 같은 자료구조로 쓸 수 있고, 비트 단위로 쪼갤 수 있기 때문에 &lt;code&gt;&amp;lt;&amp;lt;H, Rest/binary&amp;gt;&amp;gt;&lt;/code&gt; 처럼 bit syntax를 써서 바이너리 데이터를 쉽게 파싱할 수도 있다. 앞의 'Hello World!' 문자열에 적용하면 첫 한 바이트를 얻을 수 있을 것이다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;1&amp;gt; &amp;lt;&amp;lt;H, Rest/binary&amp;gt;&amp;gt; = &amp;lt;&amp;lt;&quot;Hello World!&quot;&amp;gt;&amp;gt;.
&amp;lt;&amp;lt;&quot;Hello World!&quot;&amp;gt;&amp;gt;
2&amp;gt; H.
72
3&amp;gt; Rest.
&amp;lt;&amp;lt;&quot;ello World!&quot;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만약 어떤 방법으로 IP 패킷을 받았다면 (예를 들면 &lt;code&gt;Packet&lt;/code&gt; 변수에), 다음과 같이 한 번 실행에 손쉽게 IP 헤더를 분석할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;IpVer:4, HLen:4, SvcType:8, TotLen:16, 
  Id:16, Flags:3, FragOff:13, TTL:8, Proto:8, HdrChkSum:16,
  SrcIP:32, DstIP:32, IpPayload/binary&amp;gt;&amp;gt; = Packet.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bit syntax를 보면 변수 명 뒤에 &lt;code&gt;:&lt;/code&gt; 다음에는 얻어낼 바이너리 데이터의 비트 단위의 크기를 표시한다. 그래서 &lt;code&gt;IpVer&lt;/code&gt; 변수에는 IP 헤더의 첫 4비트 필드의 값이 들어간다. 정상적인 IPv4 헤더라면 '4' 값이 들어갈 것이다.&lt;/p&gt;
&lt;p&gt;변수 명 뒤의 &lt;code&gt;/&lt;/code&gt; 다음에는 해당 변수에 넣는 바이너리 데이터의 type을 나타낸다. erlang reference manual을 참고하면 여기에는 다음 중 하나의 값을 사용할 수 있다. 생략할 경우 &lt;code&gt;integer&lt;/code&gt;가 기본값이 된다.&lt;/p&gt;
&lt;pre class=&quot;coq&quot;&gt;&lt;code&gt;Type = integer | float | binary | bytes | bitstring | bits | utf8 | utf16 | utf32&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이외에도 &lt;code&gt;signed&lt;/code&gt;/&lt;code&gt;unsigned&lt;/code&gt;이나 endian 등을 더 명시할 수 있지만 다음에 다루기로 한다.&lt;/p&gt;
&lt;p&gt;Type 중 &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt;, &lt;code&gt;bitstring&lt;/code&gt;, &lt;code&gt;bits&lt;/code&gt;에 대해 좀더 구분해보자면, 먼저 &lt;code&gt;bytes&lt;/code&gt;는 &lt;code&gt;binary&lt;/code&gt;와 같고, &lt;code&gt;bits&lt;/code&gt;와 &lt;code&gt;bitstring&lt;/code&gt;은 같은 것이다. 보다 짧게 표기하기 위한 것이다. &lt;code&gt;binary&lt;/code&gt;와 &lt;code&gt;bitstring&lt;/code&gt;은 데이터를 byte (즉 8 bit) 단위로 구분하느냐 bit 단위로 구분하느냐 차이이다. 아래 예의 경우 &lt;code&gt;X&lt;/code&gt;에는 1이, &lt;code&gt;Y&lt;/code&gt;에는 &lt;code&gt;&amp;lt;&amp;lt;2,3,4&amp;gt;&amp;gt;&lt;/code&gt;가 매치된다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;1&amp;gt; &amp;lt;&amp;lt;X, Y/binary&amp;gt;&amp;gt; = &amp;lt;&amp;lt;1, 2, 3, 4&amp;gt;&amp;gt;.
&amp;lt;&amp;lt;1,2,3,4&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러나 아래처럼 &lt;code&gt;X&lt;/code&gt;에 바이너리 데이터의 첫 7 bit를 매치시켜놓으면 나머지는 byte 단위로 딱 떨어지지 않고 25 bit가 되기 때문에 예외 에러가 발생한다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;1&amp;gt; &amp;lt;&amp;lt;X:7, Y/binary&amp;gt;&amp;gt; = &amp;lt;&amp;lt;1, 2, 3, 4&amp;gt;&amp;gt;.
** exception error: no match of right hand side value &amp;lt;&amp;lt;1,2,3,4&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 경우에는 &lt;code&gt;X&lt;/code&gt;에 매치되는 데이터의 길이를 byte로 바로 잡든가, 아니면 아래와 같이 &lt;code&gt;Y&lt;/code&gt;에 25 bit 데이터를 매치시키도록 type을 바꿔야 한다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;1&amp;gt; &amp;lt;&amp;lt;X:7, Y/bitstring&amp;gt;&amp;gt; = &amp;lt;&amp;lt;1, 2, 3, 4&amp;gt;&amp;gt;.
&amp;lt;&amp;lt;1,2,3,4&amp;gt;&amp;gt;
2&amp;gt; X.
0
3&amp;gt; Y.
&amp;lt;&amp;lt;129,1,130,0:1&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;X&lt;/code&gt;는 첫 7 bit만 읽었기 때문에 0이 매치됐고, &lt;code&gt;Y&lt;/code&gt;의 경우 &lt;code&gt;&amp;lt;&amp;lt;2, 3, 4&amp;gt;&amp;gt;&lt;/code&gt;가 1 bit 씩 오른쪽으로 쉬프트되는 꼴이 되어서 이진수로는 &lt;code&gt;10000001&lt;/code&gt;, &lt;code&gt;00000001&lt;/code&gt;, &lt;code&gt;10000010&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;가 되어 위에서 표기된 것처럼 &lt;code&gt;&amp;lt;&amp;lt;129, 1, 130, 0:1&amp;gt;&amp;gt;&lt;/code&gt;이 매치되었다.&lt;/p&gt;</description>
<category>기술</category>
<category>Erlang</category>
<author>devage</author>
<guid>https://devage.tistory.com/57</guid>
<comments>https://devage.tistory.com/57#entry57comment</comments>
<pubDate>Thu, 22 Aug 2019 21:07:57 +0900</pubDate>
</item>
<item>
<title>Erlang으로 CPU Usage 확인하는 코드 작성하기</title>
<link>https://devage.tistory.com/56</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.03.20에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;erlang cpu usage&quot; 등으로 검색하면 erlang 내에 &lt;code&gt;cpu_sup&lt;/code&gt;이 포함되어 있음을 알 수 있다. 하지만 바로 돌려보면 &lt;code&gt;0&lt;/code&gt;이라는 상당히 불성실한 값과 함께 warning report를 출력하고 종료된다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;Eshell V8.2.2  (abort with ^G)
1&amp;gt; cpu_sup:util().
0

=WARNING REPORT==== 17-Mar-2017::23:32:57 ===
OS_MON (cpu_sup) called by &amp;lt;0.57.0&amp;gt;, not started
2&amp;gt; &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;erlang man 페이지를 읽어보면 사전에 &lt;code&gt;os_mon&lt;/code&gt; application이 실행되어 있어야 한다고 한다. 이건 erlang shell에서 바로 실행하는 것이 아니고, 어플리케이션의 &lt;code&gt;.app&lt;/code&gt; application resource file에 &lt;code&gt;os_mon&lt;/code&gt;을 사전에 실행하도록 수정해야 한다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;.app&lt;/code&gt; 파일에 대해 좀 더 파악하고 가자. 여기에는 해당 어플리케이션의 버전이나 설명, 리소스 정보 및 어떻게 실행할 것인지에 대한 정보를 포함한다. 파일을 들여다보면 여러가지 옵션이 있는데 이 중 &lt;code&gt;applications&lt;/code&gt; 옵션 (&lt;i&gt;복수형이다&lt;/i&gt;) 은 어플리케이션 실행 전에 의존성 등의 이유로 미리 실행시켜둬야 할 다른 어플리케이션을 명시한다. 기본적으로 모든 어플리케이션은 &lt;code&gt;kernel&lt;/code&gt;과 &lt;code&gt;stdlib&lt;/code&gt;에 대한 의존성을 갖고 있다.&lt;/p&gt;
&lt;pre class=&quot;prolog&quot;&gt;&lt;code&gt;{application, Application
  [
    ...
    {applications, [kernel, stdlib]},
    ...
]}.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;지난 번에 만든 &lt;code&gt;wssvr&lt;/code&gt;에 &lt;code&gt;os_mon&lt;/code&gt;을 추가해보자. 빌드에 &lt;code&gt;rebar3&lt;/code&gt;를 사용하기 때문에 &lt;code&gt;wssvr.app&lt;/code&gt; 대신 &lt;code&gt;wssvr.app.src&lt;/code&gt; 파일을 편집하자 (빌드를 걸면 &lt;code&gt;rebar3&lt;/code&gt;에서 자동으로 &lt;code&gt;wssvr.app.src&lt;/code&gt;로부터 &lt;code&gt;wssvr.app&lt;/code&gt; 파일을 만들어낸다).&lt;/p&gt;
&lt;pre class=&quot;prolog&quot;&gt;&lt;code&gt;...
{applications,
  [kernel,
   stdlib,
   os_mon,    % &amp;lt;-- here.
   cowboy
  ]},
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행하면 &lt;code&gt;os_mon&lt;/code&gt;이 실행되면서 프로세스 별로 progress report를 출력한 다음 erlang shell prompt를 떨군다. 여기서 &lt;code&gt;cpu_sup&lt;/code&gt;을 실행해보자.&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;&lt;code&gt;(wssvr@MacBook-Pro)1&amp;gt; cpu_sup:util().
12.48985218073504&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;util/0&lt;/code&gt; 대신 &lt;code&gt;util/1&lt;/code&gt;을 쓰면 보다 자세한 정보를 뽑아볼 수 있다.&lt;/p&gt;
&lt;pre class=&quot;prolog&quot;&gt;&lt;code&gt;(wssvr@MacBook-Pro)2&amp;gt; cpu_sup:util([per_cpu]).
[{0,17.474933401431535,82.52506659856846,[]},
 {1,8.361166523834795,91.6388334761652,[]},
 {2,15.622653644789935,84.37734635521007,[]},
 {3,8.49818318526655,91.50181681473344,[]}]&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>Erlang</category>
<author>devage</author>
<guid>https://devage.tistory.com/56</guid>
<comments>https://devage.tistory.com/56#entry56comment</comments>
<pubDate>Thu, 22 Aug 2019 20:58:30 +0900</pubDate>
</item>
<item>
<title>awk로 컬럼 값 합계 구하기</title>
<link>https://devage.tistory.com/55</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.02.06에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;특정 프로세스의 CPU 및 MEM usage 정보를 취합 출력하는 쉘 스크립트를 작성했는데, 여기에 &lt;code&gt;top&lt;/code&gt;과 &lt;code&gt;awk&lt;/code&gt;를 사용했다. 이번에는 특히 &lt;code&gt;awk&lt;/code&gt;를 유용하게 사용했다.&lt;/p&gt;
&lt;p&gt;다음은 &lt;code&gt;awk&lt;/code&gt;에 사용하기 위한 예제로 &lt;code&gt;top&lt;/code&gt; 명령의 출력문이다. 물론 리눅스 머신의 모든 프로세스를 보여주기에는 너무 많은 양이므로 (그리고 일부 보안을 위해) 내용을 가공했다. 아래 내용이 &lt;code&gt;top_result&lt;/code&gt;라는 파일에 저장되어 있다고 가정한다.&lt;/p&gt;
&lt;pre class=&quot;tap&quot;&gt;&lt;code&gt;  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    1 root      20   0   34028   3812   2540 S   0.0  0.1  15:37.54 init
 1722 root      20   0   24872   4912   3224 S   0.0  0.1   0:00.35 bash
19728 root      20   0   24796   6396   3404 S   0.0  0.2   0:00.19 bash
19820 root      20   0   24804   6324   3320 S   0.0  0.2   0:00.37 bash&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;먼저 &lt;code&gt;init&lt;/code&gt; 프로세스의 MEM usage만 찍어보자. &lt;code&gt;COMMAND&lt;/code&gt; column의 값이 &lt;code&gt;init&lt;/code&gt;인 라인의 &lt;code&gt;%MEM&lt;/code&gt; column 값을 찍으면 된다. 각각 &lt;code&gt;$12&lt;/code&gt; 와 &lt;code&gt;$10&lt;/code&gt; 컬럼이다.&lt;/p&gt;
&lt;pre class=&quot;stata&quot;&gt;&lt;code&gt;$ awk '$12 == &quot;init&quot; {print $12&quot;: &quot;$10}' ./top_result
init: 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음엔 &lt;code&gt;bash&lt;/code&gt; 프로세스의 MEM usage의 합을 구해보자. 위 예제를 사용하면 값이 세개 찍힐 뿐, 그 합을 구할 수 없다.&lt;/p&gt;
&lt;pre class=&quot;armasm&quot;&gt;&lt;code&gt;bash: 0.1
bash: 0.2
bash: 0.2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제대로 된 합을 구하기 위해서는 &lt;code&gt;{...}&lt;/code&gt; 액션과 &lt;code&gt;END&lt;/code&gt;를 배합해야 한다. 아래와 같이 각 라인에서는 &lt;code&gt;%MEM&lt;/code&gt; column의 값을 &lt;code&gt;sum&lt;/code&gt;에 더한다. &lt;code&gt;END&lt;/code&gt; 다음의 액션에서는 취합이 끝난 결과값을 출력한다.&lt;/p&gt;
&lt;pre class=&quot;stata&quot;&gt;&lt;code&gt;$ awk '$12 == &quot;bash&quot; {sum += $10} END {print $12&quot;: &quot;sum}' ./top_result
bash: 0.5&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>awk</category>
<author>devage</author>
<guid>https://devage.tistory.com/55</guid>
<comments>https://devage.tistory.com/55#entry55comment</comments>
<pubDate>Thu, 22 Aug 2019 20:54:19 +0900</pubDate>
</item>
<item>
<title>cowboy로 websocket server 만들기</title>
<link>https://devage.tistory.com/54</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.03.08에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;cowboy를 이용해서 웹소켓 연결을 받아 처리하는 예제를 작성해본다. 웹소켓 클라이언트는 node.js로 작성했다.&lt;/p&gt;
&lt;p&gt;웹소켓 서버 코드는 &lt;a href=&quot;https://github.com/ninenines/cowboy/tree/master/examples/websocket&quot;&gt;cowboy의 websocket example&lt;/a&gt;을 기반으로 했다. 웹소켓 핸들러 코드는 &lt;a href=&quot;https://ninenines.eu/docs/en/cowboy/2.0/guide/ws_handlers/&quot;&gt;cowboy 2.0 websocket handler guide&lt;/a&gt; 문서를 참고했다. rebar3를 이용한 cowboy 기반 서버 프로젝트 생성은 &lt;a href=&quot;https://www.themoorecollective.com/articles/2015/12/09/Erlang,%20Rebar3,%20and%20Cowboy&quot;&gt;Erlang, Rebar3, and Cowboy article&lt;/a&gt;이 많은 도움이 되었다.&lt;/p&gt;
&lt;p&gt;먼저, &lt;code&gt;rebar3&lt;/code&gt;로 프로젝트를 생성하자.&lt;/p&gt;
&lt;pre class=&quot;haxe&quot;&gt;&lt;code&gt;$ rebar3 new app myapp&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rebar.config&lt;/code&gt; 파일에 &lt;code&gt;cowboy&lt;/code&gt;를 dependency package로 추가한다.&lt;/p&gt;
&lt;pre class=&quot;xquery&quot;&gt;&lt;code&gt;{deps, [
    {cowboy, {git, &quot;https://github.com/ninenines/cowboy.git&quot;, {tag, &quot;2.0.0-pre.7&quot;}}}
  ]}.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cowboy&lt;/code&gt;의 &lt;code&gt;2.0.0-pre.7&lt;/code&gt; 버전을 갖고 오라는 의미이다. 특정 버전 대신 최신 HEAD 버전을 갖고오고자 할 경우에는 아래와 같이 tag 정보를 빼면 된다.&lt;/p&gt;
&lt;pre class=&quot;xquery&quot;&gt;&lt;code&gt;{deps, [
    {cowboy, {git, &quot;https://github.com/ninenines/cowboy.git&quot;}}
  ]}.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;최소 &lt;code&gt;2.0.0-pre.4&lt;/code&gt; 이상 버전으로 갖고 와야 Cowboy 2.0 용 &lt;a href=&quot;https://ninenines.eu/docs/en/cowboy/2.0/guide/ws_handlers/&quot;&gt;WebSocket Handlers&lt;/a&gt; 문서 대로 해볼 수 있다.&lt;/p&gt;
&lt;p&gt;이 참에 rebar3의 &lt;code&gt;rebar3_run&lt;/code&gt; 플러그인을 사용해서 쉽게 실행할 수 있도록 하자. &lt;code&gt;_build/default/rel/myapp/bin/myapp console&lt;/code&gt; 처럼 실행하는 대신 간단하게 &lt;code&gt;rebar3 run&lt;/code&gt;하고 실행할 수 있다. &lt;code&gt;rebar.config&lt;/code&gt;에 아래와 같이 &lt;code&gt;rebar3_run&lt;/code&gt; 플러그인을 추가한다. 이 플러그인은 release 관련 설정도 필요로 하기 때문에, &lt;code&gt;relx&lt;/code&gt; 설정도 추가한다.&lt;/p&gt;
&lt;pre class=&quot;xquery&quot;&gt;&lt;code&gt;{plugins, [rebar3_run]}.

{relx, [{release, {myapp, &quot;0.0.1&quot;}, [myapp]},
        {dev_mode, true},
        {include_erts, false},
        {extended_start_script, true}]}.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;myapp.app.src&lt;/code&gt;에 &lt;code&gt;cowboy&lt;/code&gt;를 추가해서 app 시작 시 cowboy도 실행하도록 하자.&lt;/p&gt;
&lt;pre class=&quot;prolog&quot;&gt;&lt;code&gt;{applications,
 [kernel,
  stdlib,
  cowboy    % &amp;lt;- here
 ]},&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기에서 한번 잘 실행되는 지 확인해보자. &lt;code&gt;1&amp;gt;&lt;/code&gt; 프롬프트가 떨어지면 &lt;code&gt;q().&lt;/code&gt;을 입력해서 종료하자.&lt;/p&gt;
&lt;pre class=&quot;perl&quot;&gt;&lt;code&gt;$ rebar3 run
===&amp;gt; Verifying dependencies...
(...)
Eshell V8.2  (abort with ^G)
(myapp@MacBook-Pro)1&amp;gt; q().&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rebar3&lt;/code&gt;로 생성한 소스 코드 중에 &lt;code&gt;src/myapp_app.erl&lt;/code&gt; 파일을 수정한다. 웹 서버의 &quot;/&quot; 경로로 들어온 연결을 websocket으로 바꾸고 &lt;code&gt;ws_handler&lt;/code&gt; 모듈을 통해 처리하게 될 것이다.&lt;/p&gt;
&lt;pre class=&quot;livescript&quot;&gt;&lt;code&gt;%% from
start(_StartType, _StartArgs) -&amp;gt;
  myapp_sup:start_link().
%% to
start(_Type, _Args) -&amp;gt;
  Routes = [
    {'_', [
      {&quot;/&quot;, ws_handler, []}
    ]}],
  Dispatch = cowboy_router:compile(Routes),
  NAcceptors = 100,
  TransOpts = [{ip, {0, 0, 0, 0}}, {port, 8080}],
  ProtoOpts = #{env =&amp;gt; #{dispatch =&amp;gt; Dispatch}},
  {ok, _} = cowboy:start_clear(http, NAcceptors, TransOpts, ProtoOpts),
  myapp_sup:start_link().&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 &lt;code&gt;src/ws_handler.erl&lt;/code&gt; 파일을 만들어 다음과 같이 작성한다. 코드는 &lt;code&gt;examples/websocket/&lt;/code&gt;에 있는 것을 그대로 사용했다.&lt;/p&gt;
&lt;pre class=&quot;erlang&quot;&gt;&lt;code&gt;-module(ws_handler).

-export([init/2]).
-export([websocket_init/1]).
-export([websocket_handle/2]).
-export([websocket_info/2]).

init(Req, Opts) -&amp;gt;
  {cowboy_websocket, Req, Opts}.

websocket_init(State) -&amp;gt;
  erlang:start_timer(1000, self(), &amp;lt;&amp;lt;&quot;Hello!&quot;&amp;gt;&amp;gt;),
    {ok, State}.

websocket_handle({text, Msg}, State) -&amp;gt;
  {reply, {text, &amp;lt;&amp;lt; &quot;That's what she said! &quot;, Msg/binary &amp;gt;&amp;gt;}, State};
websocket_handle(_Data, State) -&amp;gt;
  {ok, State}.

websocket_info({timeout, _Ref, Msg}, State) -&amp;gt;
  erlang:start_timer(1000, self(), &amp;lt;&amp;lt;&quot;How' you doin'?&quot;&amp;gt;&amp;gt;),
    {reply, {text, Msg}, State};
websocket_info(_Info, State) -&amp;gt;
  {ok, State}.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 웹소켓 클라이언트를 만들어보자. node.js나 npm은 이미 설치되어 있다고 가정한다. 위 웹소켓 서버 프로젝트의 루트 디렉토리에 &lt;code&gt;client/&lt;/code&gt; 디렉토리를 만들고 이 안에 다음과 같이 &lt;code&gt;ws_client.js&lt;/code&gt;를 작성한다.&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;&lt;code&gt;var WebSocket = require('ws');
var ws = new WebSocket('ws://localhost:8080/');

ws.on('open', function open() {
    ws.send('Hi!');
});

ws.on('message', function(data, flags) {
    console.log('receive: ' + data);
});

ws.on('error', function(error) {
    console.log('error: ' + error);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ws&lt;/code&gt; 모듈을 설치한다.&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;&lt;code&gt;$ npm install --save ws&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;서버와 클라이언트를 차례대로 실행해서 테스트한다.&lt;/p&gt;
&lt;pre class=&quot;prolog&quot;&gt;&lt;code&gt;$ rebar3 run
===&amp;gt; Verifying dependencies...
===&amp;gt; Compiling myapp
===&amp;gt; Starting relx build process ...
(...)
Erlang/OTP 19 [erts-8.2.2] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Eshell V8.2.2  (abort with ^G)
(myapp@MacBook-Pro)1&amp;gt; &lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot;matlab&quot;&gt;&lt;code&gt;$ node ws_client.js
receive: That's what she said! Hi!
receive: Hello!
receive: How' you doin'?
receive: How' you doin'?
receive: How' you doin'?
receive: How' you doin'?
receive: How' you doin'?
...&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>Cowboy</category>
<category>Erlang</category>
<category>node.js</category>
<category>websocket</category>
<author>devage</author>
<guid>https://devage.tistory.com/54</guid>
<comments>https://devage.tistory.com/54#entry54comment</comments>
<pubDate>Thu, 22 Aug 2019 15:55:24 +0900</pubDate>
</item>
<item>
<title>`cowboy_bstr` 분석</title>
<link>https://devage.tistory.com/53</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.01.27에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cowboy_bstr&lt;/code&gt; 모듈은 binary string을 다루는 utility 함수들을 포함하고 있으며 cowboy에서 사용하기 위한 것이다. erlang의 특징인 패턴 매칭에 의한 함수 분기와 함께, 리스트 해석구문과 유사한 bit string 해석구문을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char_to_lower/1&lt;/code&gt;, &lt;code&gt;char_to_upper/1&lt;/code&gt;는 한 캐릭터를 소문자로 혹은 대문자로 바꾸는 함수이다. 코드는 간단하다. 인수가 &amp;rsquo;A&amp;rsquo;부터 &amp;lsquo;Z&amp;rsquo;까지 알파벳 중의 하나에 해당되면 대문자 또는 소문자를 반환한다. 그 외에는 인수를 그대로 반환한다.&lt;/p&gt;
&lt;pre class=&quot;erlang&quot;&gt;&lt;code&gt;% char_to_lower/1
char_to_lower($A) -&amp;gt; $a;
char_to_lower($B) -&amp;gt; $b;
% (C to Y ...)
char_to_lower($Z) -&amp;gt; $z;
char_to_lower(Ch) -&amp;gt; Ch.

% char_to_upper/1
char_to_upper($a) -&amp;gt; $A;
char_to_upper($b) -&amp;gt; $B;
% (c to y ...)
char_to_upper($z) -&amp;gt; $Z;
char_to_upper(Ch) -&amp;gt; Ch.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;to_lower/1&lt;/code&gt;와 &lt;code&gt;to_upper/1&lt;/code&gt; 함수는 바이너리 문자열을 대문자로 혹은 소문자로 바꾼다. 각각 한 캐릭터씩 대소문자로 바꾸는 &lt;code&gt;char_to_lower/1&lt;/code&gt;, &lt;code&gt;char_to_upper/1&lt;/code&gt; 함수를 사용하는 고차함수이며, 이를 위해 bit string 해석구문을 사용한다.&lt;/p&gt;
&lt;pre class=&quot;xl&quot;&gt;&lt;code&gt;to_lower(B) -&amp;gt;
  &amp;lt;&amp;lt; &amp;lt;&amp;lt; (char_to_lower(C)) &amp;gt;&amp;gt; || &amp;lt;&amp;lt;C&amp;gt;&amp;gt; &amp;lt;= B &amp;gt;&amp;gt;.

to_upper(B) -&amp;gt;
  &amp;lt;&amp;lt; &amp;lt;&amp;lt; (char_to_upper(C)) &amp;gt;&amp;gt; || &amp;lt;&amp;lt;C&amp;gt;&amp;gt; &amp;lt;= B &amp;gt;&amp;gt;.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;인수 &lt;code&gt;B&lt;/code&gt;를 받으면 해석구문에서는 한 캐릭터 씩 &lt;code&gt;C&lt;/code&gt;로 받는다. &lt;code&gt;||&lt;/code&gt; 좌항에서는 이를 받아서 &lt;code&gt;char_to_lower(C)&lt;/code&gt; 또는 &lt;code&gt;char_to_upper(C)&lt;/code&gt; 함수를 통해 대소문자 변환을 하고 &lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; 연산자로 바이너리 문자열로 바꾼다.&lt;/p&gt;
&lt;p&gt;다음은 리스트 해석구문과 bit string 해석구문 문법의 유사성을 한눈에 보기 위해 나란히 나열한 것이다.&lt;/p&gt;
&lt;pre class=&quot;ruby&quot;&gt;&lt;code&gt;% list comprehension (erlang.org)
[Expr || Qualifier1, ..., QualifierN]

% bit string comprehension (erlang.org)
&amp;lt;&amp;lt; BitStringExpr || Qualifier1, ..., QualifierN &amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제 사용 예는 다음과 같다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;% list comprehension (erlang.org)
1&amp;gt; [X*2 || X &amp;lt;- [1, 2, 3]].
[2, 4, 6]

% bit string comprehension (erlang.org)
2&amp;gt; &amp;lt;&amp;lt; &amp;lt;&amp;lt; (X*2) &amp;gt;&amp;gt; || &amp;lt;&amp;lt;X&amp;gt;&amp;gt; &amp;lt;= &amp;lt;&amp;lt;1, 2, 3&amp;gt;&amp;gt; &amp;gt;&amp;gt;.
&amp;lt;&amp;lt;2, 4, 6&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그 외에 &lt;code&gt;cowboy_bstr&lt;/code&gt; 모듈에는 &lt;code&gt;capitalize_token/1&lt;/code&gt; 함수가 있는데, 이 함수는 HTTP 메시지의 헤더 문자열 포맷팅하기 위한 것으로 문자열의 첫 문자와 &lt;code&gt;-&lt;/code&gt; 문자의 다음 문자만 대문자로 바꾸고 나머지는 소문자로 바꾸는 함수이다. 예를 들면 &lt;code&gt;sec-WEBSOCKET-version&lt;/code&gt;을 &lt;code&gt;Sec-Websocket-Version&lt;/code&gt; 로 바꿔준다. 코드 분석은 생략한다.&lt;/p&gt;</description>
<category>기술</category>
<category>Cowboy</category>
<category>Erlang</category>
<author>devage</author>
<guid>https://devage.tistory.com/53</guid>
<comments>https://devage.tistory.com/53#entry53comment</comments>
<pubDate>Thu, 22 Aug 2019 15:44:30 +0900</pubDate>
</item>
<item>
<title>`cowboy_clock` Module</title>
<link>https://devage.tistory.com/52</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.01.24에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cowboy&lt;/code&gt;는 erlang으로 작성한 대표적인 오픈소스 웹 서버 코드이다. 그 중 &lt;code&gt;cowboy_clock&lt;/code&gt; 모듈은 http 통신과 직접 관련은 없지만 &lt;code&gt;gen_server&lt;/code&gt; behaviour에 따라 독립 프로세스로 실행되면서 RFC1123 포맷의 시간 문자열을 내놓는다. RFC1123 표준 문서에 대한 설명은 생략하고, 쉽게 말해 다음과 같은 형식의 문자열이라고 생각하면 된다.&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;&lt;code&gt;&quot;Sat, 14 May 2011 14:25:33 GMT&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ETS-related Functions&lt;/h2&gt;
&lt;p&gt;ETS는 erlang OTP 프레임워크에서 지원하는 key-value 저장소라고 보면 된다. in-memory 저장소이며, disk 저장소 버전은 DETS라고 따로 있다. 초기화는 &lt;code&gt;gen_server&lt;/code&gt;용 &lt;code&gt;init/1&lt;/code&gt; 콜백 함수에서 한다.&lt;/p&gt;
&lt;pre class=&quot;livescript&quot;&gt;&lt;code&gt;init([]) -&amp;gt;
  ?MODULE = ets:new(?MODULE, [set, protected,
    named_table, {read_concurrency, true}]),
  T = erlang:universaltime(),
  B = update_rfc1123(&amp;lt;&amp;lt;&amp;gt;&amp;gt;, undefined, T),
  TRef = erlang:send_after(1000, self(), update),
  ets:insert(?MODULE, {rfc1123, B}),
  {ok, #state{universaltime=T, rfc1123=B, tref=TRef}}.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ETS 초기화를 한 후 현재 시간을 &lt;code&gt;T&lt;/code&gt;에 저장하고 RFC1123 문자열 형식을 &lt;code&gt;B&lt;/code&gt;에 저장한다. 그 후 ETS에 &lt;code&gt;{rfc1123, B}&lt;/code&gt; key-value 쌍을 저장한다. &lt;code&gt;erlang:send_after/3&lt;/code&gt; 함수에 의해 1초 뒤에 자신의 &lt;code&gt;handle_info(update, ...)&lt;/code&gt; 함수가 호출된다.&lt;/p&gt;
&lt;pre class=&quot;mipsasm&quot;&gt;&lt;code&gt;handle_info(update, #state{universaltime=Prev, rfc1123=B1, tref=TRef0}) -&amp;gt;
  _ = erlang:cancel_timer(TRef0),
  T = erlang:universaltime(),
  B2 = update_rfc1123(B1, Prev, T),
  ets:insert(?MODULE, {rfc1123, B2}),
  TRef = erlang:send_after(1000, self(), update),
  {noreply, #state{universaltime=T, rfc1123=B2, tref=TRef}};
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우선 1초 전에 걸었던 타이머를 캔슬한다. 그 후 동작은 &lt;code&gt;init/1&lt;/code&gt; 함수에서와 유사하다. 새로운 RFC1123 문자열을 ETS에 넣은 다음 다시 &lt;code&gt;erlang:send_after/3&lt;/code&gt; 함수에 의해 다시 1초 뒤에 &lt;code&gt;handle_info(update, ...)&lt;/code&gt; 함수가 호출된다.&lt;/p&gt;
&lt;p&gt;그러면 ETS에 저장된 key-value 데이터는 언제 사용하는가? 다음의 &lt;code&gt;rfc1123/0&lt;/code&gt; 함수에서 사용한다.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;rfc1123/*&lt;/code&gt; Functions&lt;/h2&gt;
&lt;p&gt;모듈의 주요 인터페이스는 &lt;code&gt;rfc1123/0&lt;/code&gt; 및 &lt;code&gt;rfc1123/1&lt;/code&gt; 함수로, 이 중 &lt;code&gt;rfc1123/0&lt;/code&gt; 함수는 ETS로부터 현재 시간의 RFC1123 문자열을 꺼내 반환하며, &lt;code&gt;rfc1123/1&lt;/code&gt; 함수는 특정 시간에 대한 값을 파라미터로 받아 이에 대한 RFC1123 문자열을 만들어서 반환한다.&lt;/p&gt;
&lt;pre class=&quot;livescript&quot;&gt;&lt;code&gt;rfc1123() -&amp;gt;
  ets:lookup_element(?MODULE, rfc1123, 2).

rfc1123(DateTime) -&amp;gt;
  update_rfc1123(&amp;lt;&amp;lt;&amp;gt;&amp;gt;, undefined, DateTime).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 중 &lt;code&gt;update_rfc1123/3&lt;/code&gt; 함수는 내부 함수로 나중에 다시 살펴본다.&lt;br /&gt;&lt;code&gt;DateTime&lt;/code&gt; 파라미터는 다음과 같은 형식을 가진다.&lt;/p&gt;
&lt;pre class=&quot;lsl&quot;&gt;&lt;code&gt;% {{YYYY, MM, DD}, {hh, mm, ss}}
{{2011, 5, 14}, {14, 25, 33}}&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Internal Functions&lt;/h2&gt;
&lt;h3&gt;&lt;code&gt;update_rfc1123/3&lt;/code&gt; Function&lt;/h3&gt;
&lt;p&gt;두 개의 시간 정보를 비교하여 바뀐 시간만큼 RFC1123 문자열을 수정한다. 첫번째 파라미터는 RFC1123 문자열이고, 두번째 파라미터는 RFC1123 문자열의 &lt;code&gt;DateTime&lt;/code&gt; 값이다. 세번째 파라미터는 갱신된 &lt;code&gt;DateTime&lt;/code&gt; 값이다.&lt;/p&gt;
&lt;pre class=&quot;armasm&quot;&gt;&lt;code&gt;update_rfc1123(Bin, Now, Now) -&amp;gt;
  Bin;
update_rfc1123(&amp;lt;&amp;lt;Keep:20/binary, _/bits&amp;gt;&amp;gt;,
    {Date, {H, M, _}}, {Date, {H, M, S}}) -&amp;gt;
  &amp;lt;&amp;lt;Keep/binary, (pad_int(S))/binary, &quot; GMT&quot;&amp;gt;&amp;gt;;
% ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;소스 상에서 &lt;code&gt;update_rfc1123/3&lt;/code&gt; 함수를 보면 꽤 복잡하게 작성되어 있는데, 시간 차의 정도에 따라 RFC1123 문자열 중 최소한만 수정하기 때문이다. 두 개의 시간 정보가 동일하다면 문자열 수정 없이 반환할 것이다. 만약 초 단위의 차이만 있다면 RFC1123 문자열 중 &amp;lsquo;GMT&amp;rsquo; 앞의 초 값만 수정될 것이다. 그렇지 않고 연도까지 바뀔 정도의 시간 차이라면 RFC1123 문자열을 새로 만들다시피 할 것이다. 여기서는 구체적인 코드 분석은 생략하고 넘어간다.&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;pad_int/1&lt;/code&gt; Function&lt;/h3&gt;
&lt;p&gt;한 자리 정수인 경우 앞에 &amp;lsquo;0&amp;rsquo;을 붙여주는 함수이다. 스니펫으로 저장해두면 유용하게 사용할 수 있을 듯 하다.&lt;/p&gt;
&lt;pre class=&quot;tp&quot;&gt;&lt;code&gt;pad_int(X) when X &amp;lt; 10 -&amp;gt;
  &amp;lt;&amp;lt;$0, ($0 + X)&amp;gt;&amp;gt;;
pad_int(X) -&amp;gt;
  integer_to_binary(X).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;사실 C로 작성하면 &lt;code&gt;sprintf(buf, &quot;%02d&quot;, X)&lt;/code&gt;로 간단하게 한 줄로 작성할 수 있다. 일견 허무해보이기도 하지만 C 언어의 약점은 저 &lt;code&gt;buf&lt;/code&gt;에 있다. 메모리 할당이라든가 포인터 관리라든가...&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;weekday/1&lt;/code&gt; and &lt;code&gt;month/1&lt;/code&gt; Functions&lt;/h3&gt;
&lt;p&gt;전형적으로 패턴 매칭을 활용한 함수 선언이다.&lt;/p&gt;
&lt;pre class=&quot;erlang&quot;&gt;&lt;code&gt;weekday(1) -&amp;gt; &amp;lt;&amp;lt;&quot;Mon&quot;&amp;gt;&amp;gt;;
weekday(2) -&amp;gt; &amp;lt;&amp;lt;&quot;Tue&quot;&amp;gt;&amp;gt;;
% ...
weekday(7) -&amp;gt; &amp;lt;&amp;lt;&quot;Sun&quot;&amp;gt;&amp;gt;.

month( 1) -&amp;gt; &amp;lt;&amp;lt;&quot;Jan&quot;&amp;gt;&amp;gt;;
month( 2) -&amp;gt; &amp;lt;&amp;lt;&quot;Feb&quot;&amp;gt;&amp;gt;;
% ...
month(12) -&amp;gt; &amp;lt;&amp;lt;&quot;Dec&quot;&amp;gt;&amp;gt;.&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cowboy_clock&lt;/code&gt;은 cowboy 내에서 독립적으로 실행되는 &lt;code&gt;gen_server&lt;/code&gt; 기반의 작은 프로세스이면서 ETS를 활용하고, 패턴 매칭을 많이 사용하는 재미있는 모듈이다. 개인적으로는 u&lt;code&gt;pdate_rfc1123/3&lt;/code&gt; 함수의 패턴 매칭이 좀 과하다고 생각하지만, 코드 분석을 하면서 erlang 초보인 나에게는 많은 공부가 된 소스 코드이다.&lt;/p&gt;</description>
<category>기술</category>
<category>Cowboy</category>
<category>Erlang</category>
<author>devage</author>
<guid>https://devage.tistory.com/52</guid>
<comments>https://devage.tistory.com/52#entry52comment</comments>
<pubDate>Thu, 22 Aug 2019 13:01:53 +0900</pubDate>
</item>
<item>
<title>Erlang에서 함수 실행 시간 측정하기</title>
<link>https://devage.tistory.com/51</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.01.18에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;전형적으로 함수 실행 전후에 시간을 측정한 다음 그 시간차를 계산해서 실행 시간을 측정한다. erlang에서는 다음과 같이 구현할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;mipsasm&quot;&gt;&lt;code&gt;T1 = erlang:timestamp(),
% (add your function(s) here)
T2 = erlang:timestamp(),
timer:now_diff(T2, T1).&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;전에는 &lt;code&gt;now()&lt;/code&gt;를 썼었는데 deprecated 되었고 요즘은 &lt;code&gt;erlang:timestamp()&lt;/code&gt;를 사용한다.&lt;/p&gt;
&lt;p&gt;하지만 erlang에서는 위와 같이 함수의 실행 시간을 측정할 수 있는 &lt;code&gt;timer:tc&lt;/code&gt; 함수를 사용해서 보다 간단하게 표현할 수 있다. 인수 갯수는 함수가 인수가 있는 지 없는지, 그리고 외부 모듈이냐 아니냐에 따라 &lt;code&gt;/1&lt;/code&gt;에서 &lt;code&gt;/3&lt;/code&gt;까지 세 가지 종류가 있다. 모두 반환값은 동일하며, &lt;code&gt;Time&lt;/code&gt;은 밀리초 단위이다.&lt;/p&gt;
&lt;pre class=&quot;livescript&quot;&gt;&lt;code&gt;timer:tc(Fun) -&amp;gt; {Time, Value}
timer:tc(Fun, Args) -&amp;gt; {Time, Value}
timer:tc(Mod, Fun, Args) -&amp;gt; {Timer, Value}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예로 삼아 다음과 같이 실행할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;1&amp;gt; timer:tc(io, format, [&quot;~p + ~p = ~p~n&quot;, [1, 2, 1+2]]).
1 + 2 = 3
{67,ok}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;1 + 2 = 3&lt;/code&gt;은 &lt;code&gt;io:format/2&lt;/code&gt; 함수 실행의 실행으로 인해 출력된 것이다. &lt;code&gt;{67, ok}&lt;/code&gt;는 &lt;code&gt;io:format/2&lt;/code&gt;를 실행하는데 67ms가 걸렸으며 그 반환값은 &lt;code&gt;ok&lt;/code&gt;라는 의미이다. &lt;code&gt;[&quot;~p + ~p = ~p~n&quot;, [1, 2, 1+2]]&lt;/code&gt;는 &lt;code&gt;io:format/2&lt;/code&gt;에 넘겨지는 파라미터로, &lt;code&gt;timer:tc/2&lt;/code&gt; 내부적으로는 &lt;code&gt;apply&lt;/code&gt; 함수에 의해 &lt;code&gt;io:format(&quot;~p + ~p = ~p~n&quot;, [1, 2, 1+2])&lt;/code&gt;과 동일하게 실행된다.&lt;/p&gt;</description>
<category>기술</category>
<category>Erlang</category>
<author>devage</author>
<guid>https://devage.tistory.com/51</guid>
<comments>https://devage.tistory.com/51#entry51comment</comments>
<pubDate>Wed, 21 Aug 2019 22:13:55 +0900</pubDate>
</item>
<item>
<title>binary string용 join 함수</title>
<link>https://devage.tistory.com/50</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2017.01.05에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;erlang의 &lt;code&gt;string:join/2&lt;/code&gt; 함수는 두 개의 문자열을 separator와 함께 결합해주는 역할을 한다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;1&amp;gt; string:join([&quot;Hello&quot;, &quot;World&quot;], &quot;, &quot;).
&quot;Hello, World&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보통 C 언어에서의 문자열은 char의 배열이다.&lt;/p&gt;
&lt;pre class=&quot;prolog&quot;&gt;&lt;code&gt;str[0] = 'H',
str[1] = 'e',
str[2] = 'l',
str[3] = 'l',
str[4] = 'o',
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이에 반해 erlang에서의 문자열은 char들의 리스트이다.&lt;/p&gt;
&lt;pre class=&quot;xl&quot;&gt;&lt;code&gt;str -&amp;gt; &amp;lsquo;H&amp;rsquo; -&amp;gt; &amp;lsquo;e&amp;rsquo; -&amp;gt; &amp;lsquo;l&amp;rsquo; -&amp;gt; &amp;lsquo;l&amp;rsquo; -&amp;gt; &amp;lsquo;o&amp;rsquo; -&amp;gt; &amp;hellip; -&amp;gt; (NULL)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 C에서의 문자열과 같은 자료구조가 erlang에도 있는데, binary 포맷이라고 하며 문자열의 경우 &lt;code&gt;&amp;lt;&amp;lt;&amp;ldquo;Hello&amp;rdquo;&amp;gt;&amp;gt;&lt;/code&gt; 로 표현한다. 이 보다 범용적으로는 &lt;code&gt;&amp;lt;&amp;lt;1, 2, 3, 4&amp;gt;&amp;gt;&lt;/code&gt; 처럼 byte 크기 정수의 배열을 표현할 수 있다. 그래서 &amp;ldquo;Hello&amp;rdquo;를 ASCII 코드 값의 배열로 표현하면 &lt;code&gt;&amp;lt;&amp;lt;72, 101, 108, 108, 111&amp;gt;&amp;gt;&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;p&gt;배경 설명이 길어졌는데, 그래서 &lt;code&gt;string:join/2&lt;/code&gt;는 list 문자열에 대해서만 처리하고 binary 문자열에 대해서는 지원해주지 않는다. 개인적인 필요에 의해서 한 줄 만들어서 사용하고 있었는데, 이것 보다는 잘 작성된 코드를 우연히 찾아서 여기에 공유해보고자 한다. 출처는 &lt;a href=&quot;https://coderwall.com/p/nmajna/joining-a-list-of-binaries-in-erlang&quot;&gt;Joining A List Of Binaries In Erlang (Example)&lt;/a&gt; 이다.&lt;/p&gt;
&lt;pre class=&quot;livescript&quot;&gt;&lt;code&gt;binary_join([], _Sep) -&amp;gt;
  &amp;lt;&amp;lt;&amp;gt;&amp;gt;;
binary_join([Part], _Sep) -&amp;gt;
  Part;
binary_join(List, Sep) -&amp;gt;
  lists:foldr(fun (A, B) -&amp;gt;
    if
      bit_size(B) &amp;gt; 0 -&amp;gt; &amp;lt;&amp;lt;A/binary, Sep/binary, B/binary&amp;gt;&amp;gt;;
      true -&amp;gt; A
    end
  end, &amp;lt;&amp;lt;&amp;gt;&amp;gt;, List).

% binary_join([&amp;lt;&amp;lt;&quot;Hello&quot;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&quot;World&quot;&amp;gt;&amp;gt;], &amp;lt;&amp;lt;&quot;, &quot;&amp;gt;&amp;gt;).
% &amp;lt;&amp;lt;&quot;Hello, World&quot;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>Erlang</category>
<author>devage</author>
<guid>https://devage.tistory.com/50</guid>
<comments>https://devage.tistory.com/50#entry50comment</comments>
<pubDate>Wed, 21 Aug 2019 22:10:52 +0900</pubDate>
</item>
<item>
<title>Erlang/OTP 19.2 릴리즈 소식</title>
<link>https://devage.tistory.com/49</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2016.12.15에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;올해의 마지막 달 중반에 Erlang 19의 두번째 서비스 버전이 릴리즈됐다. 19.1이 릴리즈 된 지 약 3개월 만이다. 만약 19.3이 나온다면 내년 3월이 될 것으로 보인다.&lt;/p&gt;
&lt;p&gt;주요 변경 사항으로는 다음 세 가지가 있다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;b&gt;&lt;code&gt;gen_statem&lt;/code&gt; behaviour의 기능 향상&lt;/b&gt;: generic state machine의 약자이다. 기존의 &lt;code&gt;gen_fsm&lt;/code&gt; (generic final state machine) behaviour를 대체하기 위한 것으로, 19.0부터 소개되었다. ssh 모듈이 &lt;code&gt;gen_statem&lt;/code&gt; 덕분에 성능이 많이 개선되었다고 하니, 기대해도 좋을 것으로 보인다.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;DTLS 지원&lt;/b&gt;: 아직 experimental version이기 때문에 production 수준의 사용은 힘들다고 한다. DTLS를 사용하려면 &lt;code&gt;ssl:connect&lt;/code&gt;나 &lt;code&gt;ssl:listen&lt;/code&gt; 함수에 &lt;code&gt;{protocol, dtls}&lt;/code&gt; 옵션을 추가해야 한다. DTLS는 &amp;lsquo;Datagram TLS&amp;rsquo;의 줄임말로, TLS (transport layer security)가 TCP 위에서 사용하는 것에 반해 이것은 말 그대로 UDP용 TLS라는 뜻이다. 대표적으로 CoAP 프로토콜이 UDP 기반이기 때문에 보안을 강화할 경우 DTLS가 사용될 것이다. 또한 WebRTC에서는 RTP 패킷을 SRTP로 암호화하기 위한 키를 교환하기 위해 mandatory 방식으로 DTLS를 사용하도록 하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;code&gt;ssh:connect&lt;/code&gt; 함수에 &lt;code&gt;silently_accept_hosts&lt;/code&gt; 옵션 추가&lt;/b&gt;: 이 부분은 잘 아는 분야가 아니라서 보충 설명이 힘들다. 관심 있는 분은 SSH reference manual을 참고하기 바란다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이외에도 약 40개에 달하는 마이너 패치가 이루어졌는데 이는 19.1 때보다 더 많은 개선이 이루어지는 것이다. 올해 19.x 버전에서는 SSL과 SSH 관련하여 많은 개선이 이루어지고 있는 듯 하다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 다음 링크를 참고하기 바란다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.erlang.org/news/109&quot;&gt;Erlang/OTP 19.2 has been released&lt;/a&gt;&lt;/p&gt;</description>
<category>기술</category>
<category>dtls</category>
<category>Erlang</category>
<author>devage</author>
<guid>https://devage.tistory.com/49</guid>
<comments>https://devage.tistory.com/49#entry49comment</comments>
<pubDate>Wed, 21 Aug 2019 21:40:03 +0900</pubDate>
</item>
<item>
<title>WebRTC에서 카메라 전후면 정보 확인하는 다른 방법</title>
<link>https://devage.tistory.com/48</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2016.12.13에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MediaStreamTrack.getSources()&lt;/code&gt;의 정보 중 &lt;code&gt;label&lt;/code&gt; 값을 parsing하면 해당 &lt;code&gt;id의&lt;/code&gt; 카메라가 전면인지 후면인지 식별할 수 있다. 그러나 crosswalk에 내장된 webview를 사용하면 &lt;code&gt;label&lt;/code&gt; 정보가 비어 있어서 이에 대한 식별이 불가능하다 (version 22.52.561.4). 새로 추가된 API인 &lt;code&gt;navigator.mediaDevices.enumerateDevices&lt;/code&gt;에서도 &lt;code&gt;label&lt;/code&gt; 정보가 누락되어 있었다.&lt;/p&gt;
&lt;p&gt;bug tracking 정보를 검색해보니, 크롬에서는 한번 버그 레포팅 되었지만, 이미 해결되어서 현재 크롬에서는 &lt;code&gt;label&lt;/code&gt; 값을 활용할 수 있다. 그러나 크로미움에서는 해당 버그 패치가 아직 반영되지 않은 듯 하다.&lt;/p&gt;
&lt;p&gt;그런데 현재 표준에는 &lt;code&gt;facing&lt;/code&gt; 필드가 삭제되어 있지만, chromium webview에서는 아직 표준 내용이 반영되지 않았는지 해당 필드를 사용할 수 있었다. 곧 없어질 정보이지만 그 때 쯤이면 &lt;code&gt;label&lt;/code&gt; 필드의 버그로 수정될 것으로 보이기 때문에 당분간 사용 가능할 것으로 보인다.&lt;/p&gt;
&lt;p&gt;아래와 같이 &lt;code&gt;facing&lt;/code&gt; 값이 &amp;ldquo;user&amp;rdquo;면 전면 카메라, &amp;ldquo;environment&amp;rdquo;이면 후면 카메라이다.&lt;/p&gt;
&lt;pre class=&quot;actionscript&quot;&gt;&lt;code&gt;MediaStreamTrack.getSources(function(srcs) {
    for(var i = 0; i &amp;lt; srcs.length; i++) {
        if(srcs[i].kind == &quot;video&quot;) {
            // facing == &quot;user&quot; -&amp;gt; front
            // facing == &quot;environment&quot; -&amp;gt; back
            alert(srcs[i].facing);
        }
    }
});&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>Android</category>
<category>Chromium</category>
<category>webrtc</category>
<author>devage</author>
<guid>https://devage.tistory.com/48</guid>
<comments>https://devage.tistory.com/48#entry48comment</comments>
<pubDate>Wed, 21 Aug 2019 21:35:15 +0900</pubDate>
</item>
<item>
<title>vim 관련 팁</title>
<link>https://devage.tistory.com/47</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2016.11.20에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;파일 끝에 개행문자 붙지 않게 하기&lt;/h2&gt;
&lt;p&gt;vim으로 한줄만 입력하고 저장하면 뒤에 개행문자가 붙는다. 아래 예의 경우 &lt;code&gt;xxd&lt;/code&gt; 출력문 중 마지막의 &lt;code&gt;0a&lt;/code&gt;가 개행문자이다 저장 후 파일 크기도 7 바이트가 아니라 8 바이트이다.&lt;/p&gt;
&lt;pre class=&quot;stylus&quot;&gt;&lt;code&gt;$ vi a.txt
abcdefg
$ xxd a.txt 
00000000: 6162 6364 6566 670a                      abcdefg.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;개행문자가 자동으로 붙지 않게 하려면 &lt;code&gt;.vimrc&lt;/code&gt;에 다음 설정을 추가한다.&lt;/p&gt;
&lt;pre class=&quot;gams&quot;&gt;&lt;code&gt;set binary
set noeol&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다시 위의 예를 반복해보면 개행문자가 붙지 않는 것을 확인할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;stylus&quot;&gt;&lt;code&gt;$ vi a.txt
abcdefg
$ xxd a.txt 
00000000: 6162 6364 6566 67                        abcdefg&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;특정 단어가 포함된 라인 삭제&lt;/h2&gt;
&lt;pre class=&quot;elixir&quot;&gt;&lt;code&gt;:%g/&amp;lt;string&amp;gt;/d&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 삭제가 아니라 replace를 원할 때에는 다음과 같이 한다.&lt;/p&gt;
&lt;pre class=&quot;elixir&quot;&gt;&lt;code&gt;:%s/&amp;lt;old-string&amp;gt;/&amp;lt;new-string&amp;gt;/g&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>vim</category>
<author>devage</author>
<guid>https://devage.tistory.com/47</guid>
<comments>https://devage.tistory.com/47#entry47comment</comments>
<pubDate>Wed, 21 Aug 2019 21:32:02 +0900</pubDate>
</item>
<item>
<title>kerl</title>
<link>https://devage.tistory.com/46</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2016.11.11에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kerl/kerl&quot;&gt;kerl&lt;/a&gt;은 여러 버전의 &lt;a href=&quot;https://www.erlang.org&quot;&gt;Erlang/OTP&lt;/a&gt; (이하 'erlang')을 보다 손쉽게 빌드하고 설치 및 관리하기 위한 툴이다.&lt;/p&gt;
&lt;p&gt;굳이 kerl을 몰라도 macOS에서는 &lt;code&gt;brew&lt;/code&gt;만으로도 쉽게 erlang 패키지를 설치하고 사용할 수 있다. 리눅스에서도 배포판에 따라 &lt;code&gt;apt-get&lt;/code&gt;이나 &lt;code&gt;yum&lt;/code&gt; 등의 패키지 관리 시스템을 통해 쉽게 설치할 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 때때로 내가 원하는 버전으로, 내가 원하는 기능만을 포함하여 직접 erlang을 빌드할 필요가 생긴다. 하나 더 이유를 들자면, 리눅스나 맥의 패키지 관리 시스템에서 최신 버전을 제공하지 못할 때가 있다. 현재 우분투 16.10에서의 erlang 기본 설치 버전은 18.x로, erlang 최신 버전인 19.1 보다는 구식이다. 맥은 이보다 상황이 좋지만 &lt;code&gt;brew&lt;/code&gt;에서 최신 버전을 지원해줄 떄까지 손가락만 빨고 있어야 한다.&lt;/p&gt;
&lt;p&gt;그리고 kerl을 사용해서 동시에 여러 버전을 빌드해서 설치하고, 필요에 따라 골라 쓰고 쉽게 삭제할 수 있다. node.js 사용자라면 &lt;code&gt;nvm&lt;/code&gt;을 생각하면 이해하기 쉬울 것이다.&lt;/p&gt;
&lt;p&gt;다음은 우분투에서 kerl을 이용해 erlang을 빌드, 설치, 사용, 삭제하는 방법을 간략하게 설명한다. 사전에 &lt;code&gt;apt-get&lt;/code&gt;으로 설치해야 하는 패키지들이 있는데, 아쉽게도 체계적으로 정리하지 못했다. 다음은 설치한 패키지들 중 일부이다. &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt; 등 빌드 툴은 이미 설치한 것으로 가정한다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;code&gt;libncurses5-dev&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libssl-dev&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unixodbc-dev&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;libgtk2.0-dev&lt;/code&gt;, &lt;code&gt;libwxbase2.8&lt;/code&gt;, &lt;code&gt;libwxgtk2.8-dev&lt;/code&gt; (버전 정보가 달라질 수 있다)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이외에 &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt;도 사용할 수 있는 상태여야 한다.&lt;/p&gt;
&lt;h2&gt;kerl 설치&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;curl&lt;/code&gt;로 kerl을 다운로드 받아 실행옵션을 주고 사용한다. kerl의 실체는 쉘스크립트이다.&lt;/p&gt;
&lt;pre class=&quot;awk&quot;&gt;&lt;code&gt;$ curl -O https://raw.githubusercontent.com/kerl/kerl/master/kerl
$ chmod +x kerl&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;erlang release 확인&lt;/h2&gt;
&lt;p&gt;빌드 가능한 erlang release 정보를 확인할 수 있다. 이 정보는 &lt;code&gt;$HOME/.kerl/&lt;/code&gt; 밑에 저장된다. 앞으로 kerl을 이용한 다운로드 소스 파일, 빌드 파일은 모두 여기에 저장된다.&lt;br /&gt;그리고 앞으로 새로운 버전이 릴리즈 될 때마다 &lt;code&gt;kerl update releases&lt;/code&gt; 명령으로 release 정보를 업데이트할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;lsl&quot;&gt;&lt;code&gt;$ kerl list releases
R10B-0 R10B-10 R10B-1a R10B-2 R10B-3 R10B-4 R10B-5 R10B-6 R10B-7 R10B-8 R10B-9 R11B-0 R11B-1 R11B-2 R11B-3 R11B-4 R11B-5 R12B-0 R12B-1 R12B-2 R12B-3 R12B-4 R12B-5 R13A R13B01 R13B02-1 R13B02 R13B03 R13B04 R13B R14A R14B01 R14B02 R14B03 R14B04 R14B R14B_erts-5.8.1.1 R15B01 R15B02 R15B02_with_MSVCR100_installer_fix R15B03-1 R15B03 R15B R16A_RELEASE_CANDIDATE R16B01 R16B02 R16B03-1 R16B03 R16B 17.0-rc1 17.0-rc2 17.0 17.1 17.3 17.4 17.5 18.0 18.1 18.2 18.2.1 18.3 19.0 19.1
Run 'kerl update releases' to update this list from erlang.org&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kerl list releases&lt;/code&gt; 외에도 &lt;code&gt;kerl list builds&lt;/code&gt;, &lt;code&gt;kerl list installations&lt;/code&gt; 명령으로 현재 빌드와 설치 내역을 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;빌드&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;kerl build&lt;/code&gt; 다음에 빌드할 release 정보를 지정해주고 그 다음에 빌드 이름을 지어서 실행한다.&lt;/p&gt;
&lt;pre class=&quot;armasm&quot;&gt;&lt;code&gt;$ kerl build 19.1 r19_1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;KERL_CONFIGURE_OPTIONS&lt;/code&gt; 환경 변수로 erlang 빌드 전에 &lt;code&gt;configure&lt;/code&gt; 실행 시 옵션을 추가할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;armasm&quot;&gt;&lt;code&gt;$ KERL_CONFIGURE_OPTIONS=&quot;--with-dynamic-trace=dtrace&quot; kerl build 19.1 r19_1_dtrace&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자세한 옵션은 erlang 소스 압축 파일을 풀어 그 안의 &lt;code&gt;configure --help&lt;/code&gt; 명령을 실행하여 확인하면 된다.&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;p&gt;에러 없이 빌드가 잘 되면, &lt;code&gt;kerl install&lt;/code&gt; 명령으로 설치한다. 설치할 디렉토리를 지정해준다.&lt;/p&gt;
&lt;pre class=&quot;awk&quot;&gt;&lt;code&gt;$ kerl install r19_1 /somewhere/you/want&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;활성화&lt;/h2&gt;
&lt;p&gt;설치된 erlang의 &lt;code&gt;erl&lt;/code&gt; 등을 사용할 수 있도록 &lt;code&gt;$PATH&lt;/code&gt; 환경 변수에 등록하는 등의 작업을 진행한다. erlang 설치 시 &lt;code&gt;activate&lt;/code&gt; 쉘스크립트가 kerl에 의해 추가된다.&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;&lt;code&gt;$ source /somewhere/you/want/activate&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;비활성화하고자 할 때에는 &lt;code&gt;kerl_deactivate&lt;/code&gt;를 실행한다.&lt;/p&gt;
&lt;h2&gt;삭제&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;kerl delete&lt;/code&gt; 명령으로 빌드 및 설치본을 삭제할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;n1ql&quot;&gt;&lt;code&gt;$ kerl delete build r19_1
$ kerl delete installation r19_1&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;기타&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;kerl status&lt;/code&gt; 명령으로 현재 사용 가능한 빌드, 설치본, 활성화된 설치본을 확인할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;&lt;code&gt;$ kerl status
Available builds:
19.1,r19_1
19.1,r19_1_dtrace
----------
Available installations:
r19_1 /somewhere/you/want/r19_1
r19_1_dtrace /somewhere/you/want/r19_1_dtrace
----------
The current active installation is:
/somewhere/you/want/r19_1
There's no Dialyzer PLT for the active installation&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kerl active&lt;/code&gt; 명령으로 현재 활성화된 설치본에 대한 정보를 확인할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;gams&quot;&gt;&lt;code&gt;$ kerl active
The current active installation is:
/somewhere/you/want/r19_1
$ kerl_deactivate
$ kerl active
No Erlang/OTP kerl installation is currently active&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;끝으로, &lt;code&gt;kerl deploy&lt;/code&gt; 명령으로 현재 활성화된 설치본을 다른 서버에 복사해서 설치할 수 있다. 네트워크 전송은 ssh나 scp를 사용한다. 물론 타겟 서버에도 필요한 패키지들이 사전에 설치되어 있어야 실행 시 오류가 발생하지 않는다.&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;&lt;code&gt;kerl deploy user@target.host /remote/directory&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;끝으로 erlang 빌드를 위해 ubuntu에 사전에 설치해야 하는 패키지들의 목록을 정리하지 못한게 아쉽다. 그리고 &lt;code&gt;KERL_CONFIGURE_OPTIONS&lt;/code&gt; 환경변수에 넣을 수 있는 옵션들을 정리하고 싶은 욕심이 있었으나, 아직 erlang 실행 환경에 익숙치 않아 좀 더 이해도가 높아진 다음에 정리 보강하고자 한다.&lt;/p&gt;</description>
<category>기술</category>
<category>Erlang</category>
<category>kerl</category>
<author>devage</author>
<guid>https://devage.tistory.com/46</guid>
<comments>https://devage.tistory.com/46#entry46comment</comments>
<pubDate>Wed, 21 Aug 2019 21:28:19 +0900</pubDate>
</item>
<item>
<title>Erlang의 iolist</title>
<link>https://devage.tistory.com/45</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2015.11.24에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;iolist는 다음을 요소로 가지는 리스트 type이다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;0부터 255 사이의 값을 가지는 정수 (즉, 1바이트 크기 정수)&lt;/li&gt;
&lt;li&gt;binary&lt;/li&gt;
&lt;li&gt;iolist&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음은 iolist의 한 예이다.&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;&lt;code&gt;1&amp;gt; String = [$H, $e, $l, $l, $o, 32, [&quot;Wor&quot;, [&amp;lt;&amp;lt;&quot;ld&quot;&amp;gt;&amp;gt;]]].
[72,101,108,108,111,32,[&quot;Wor&quot;,[&amp;lt;&amp;lt;&quot;ld&quot;&amp;gt;&amp;gt;]]]&lt;/code&gt;&lt;/pre&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;code&gt;$H&lt;/code&gt;는 ASCII 문자이며 0..255 사이의 범위에 속하는 정수로 나타낼 수 있다.&lt;/li&gt;
&lt;li&gt;32도 0..255 범위의 정수이다 (ASCII 문자로는 space에 해당한다).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;Wor&quot;&lt;/code&gt;는 문자열로, Erlang에서 문자열은 ASCII 문자의 리스트이고 결국 정수의 리스트이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&quot;ld&quot;&amp;gt;&amp;gt;&lt;/code&gt;는 binary이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;lt;&amp;lt;&quot;ld&quot;&amp;gt;&amp;gt;]&lt;/code&gt;와 &lt;code&gt;[&quot;Wor&quot;, [&amp;lt;&amp;lt;&quot;ld&quot;&amp;gt;&amp;gt;]]&lt;/code&gt; 또한 iolist의 범주에 포함된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;iolist의 장점은 실제로 Screen I/O나 socket I/O 함수를 통해 출력할 때 있다. 보낼 데이터가 들어있는 리스트가 그 안에 또 다른 리스트를 가지고 있는 등 복잡한 구조로 구성되어 있으면 I/O 함수에 보내기 전에 한번 flatten시켜서 보내는게 일반적인데, erlang I/O 함수는 내부에서 iolist type의 리스트를 flatten 해준다. 따라서 위의 &lt;code&gt;String&lt;/code&gt; 변수의 리스트를 &lt;code&gt;io:format/2&lt;/code&gt;으로 그대로 보내도 동작한다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;2&amp;gt; io:format(&quot;~s~n&quot;, [String]).
Hello World
ok&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 편리한 함수이지만 모든 값을 받을 수 있는 것이 아니다. 앞에서 설명했듯이, iolist 리스트의 각 요소는 '0부터 255 사이의 값을 가지는 정수'이기 때문에 다음은 오류로 처리된다.&lt;/p&gt;
&lt;h2&gt;1. &lt;code&gt;atom()&lt;/code&gt; type&lt;/h2&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;3&amp;gt; AtomList = [hello, world].
[hello,world]
4&amp;gt; io:format(&quot;~s~n&quot;, [AtomList]).
** exception error: bad argument
     in function  io:format/3
        called as io:format(&amp;lt;0.26.0&amp;gt;,&quot;~s~n&quot;,[[hello,world]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;atom&lt;/code&gt;은 심볼처럼 다루기 때문에 erlang 내부로는 복잡한 구조체의 형태로 다룬다. 따라서 &lt;code&gt;atom_to_binary/2&lt;/code&gt; 또는 &lt;code&gt;atom_to_list/1&lt;/code&gt; 같은 변환 함수를 사용해서 문자열로 바꾸어야 한다.&lt;/p&gt;
&lt;h2&gt;2. 255보다 큰 정수&lt;/h2&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;5&amp;gt; BigIntList = [1048576].
[1048576]
6&amp;gt; io:format(&quot;~s~n&quot;, [BigIntList]). 
** exception error: bad argument
     in function  io:format/3
        called as io:format(&amp;lt;0.26.0&amp;gt;,&quot;~s~n&quot;,[[1048576]])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;특히 기존 C/C++에 익숙한 프로그래머라면 255보다 큰 정수의 경우 2개, 4개 이상의 바이트를 차지할 것이고 그 값을 구성하는 각 바이트가 개별적으로 처리될 것이라고 추측하기 쉽다. 그래서 big endian이냐 little endian이냐만 고민할 것인데, elrang에서는 에러로 처리해버린다.&lt;/p&gt;
&lt;p&gt;따라서 직접 정수의 리스트로 쪼개야 하며, 그 중 한 방법은 &lt;code&gt;binary:encode_unsigned/1&lt;/code&gt;나 &lt;code&gt;binary:encode_unsigned/2&lt;/code&gt;를 사용하는 것이다.&lt;/p&gt;
&lt;pre class=&quot;erlang-repl&quot;&gt;&lt;code&gt;7&amp;gt; binary:encode_unsigned(1048576).
&amp;lt;&amp;lt;16,0,0&amp;gt;&amp;gt;
8&amp;gt; binary:encode_unsigned(1048576, little).
&amp;lt;&amp;lt;0,0,16&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>Erlang</category>
<category>iolist</category>
<author>devage</author>
<guid>https://devage.tistory.com/45</guid>
<comments>https://devage.tistory.com/45#entry45comment</comments>
<pubDate>Wed, 21 Aug 2019 21:17:37 +0900</pubDate>
</item>
<item>
<title>HTTP-CoAP Mapping draft 정리</title>
<link>https://devage.tistory.com/44</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2015.12.09에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(이 포스트는 IETF Core WG의 &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-core-http-mapping-07&quot;&gt;draft&lt;/a&gt; &quot;Guidelines for HTTP-CoAP Mapping Implementations&quot;의 내용을 정리한 것입니다.)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7252&quot;&gt;CoAP&lt;/a&gt;은 센서와 원활한 REST 기반의 통신을 하기 위한 프로토콜이다. 센서와 통신하기 위해서는 클라이언트에서도 CoAP이 구현되어 있어야 하는데, 우리가 접할 수 있는 대부분의 단말 (스마트폰, PC, ...)에는 당연히(!) 구현되어 있지 않다.&lt;/p&gt;
&lt;p&gt;그러나 만약 CoAP을 HTTP와 같은 대중적인 프로토콜로 변환할 수 있는 장비를 중간에 둔다면 웹 브라우저나 &lt;code&gt;curl&lt;/code&gt; 등 일반적인 HTTP 클라이언트를 통해서도 센서와 통신할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;중간의 이와 같은 CoAP-HTTP 변환 역할을 해주는 장비를 HTTP-CoAP Proxy (줄여서 HC proxy)라 한다.&lt;/p&gt;
&lt;p&gt;참고로 proxy는 크게 forward proxy와 reverse proxy로 나뉘는데, HTTP를 예로 들어 간단하게 설명하자면 전자는 (회사 등) 특정 사이트 안에 있는 사용자가 외부 웹에 접근할 때 사용자를 대신하여 대상 웹 서버에 접근하는 proxy이고, 후자는 반대로 외부로부터 특정 사이트의 웹 서버에 접근할 때 그 앞단에서 해당 서버와의 연결을 간접적으로 처리하는 proxy이다.&lt;/p&gt;
&lt;p&gt;HC proxy의 경우 forward proxy 방식은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7252&quot;&gt;CoAP RFC&lt;/a&gt;문서에서 정의하고 있고, 본 &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-core-http-mapping-07&quot;&gt;draft&lt;/a&gt;에서는 reverse proxy 방식에 대해서 설명한다. 해당 draft에서는 HC proxy 동작의 정의를 다음과 같은 범주로 나누어 설명하고 있다:&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;URI mapping&lt;/li&gt;
&lt;li&gt;Discovery&lt;/li&gt;
&lt;li&gt;Media type mapping&lt;/li&gt;
&lt;li&gt;Response code mapping&lt;/li&gt;
&lt;li&gt;Cache &amp;amp; congestion control, etc.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;1. URI mapping&lt;/h2&gt;
&lt;p&gt;사용자는는 기본적으로 HC proxy를 가리키는 URI (base URI)와 CoAP 센서의 특정 리소스를 가리키는 URI (target CoAP URI)를 조합한 hosting HTTP URI로 만들어 사용한다.&lt;/p&gt;
&lt;p&gt;이 중 target CoAP URI를 어떠한 방식으로 변환하여 조합할 지는 사전에 정의한 URI mapping template에 따라 명시적으로 정의된다. 이러한 정보는 다음 Discovery 섹션에서 설명하는 바와 같이 CoAP resource discovery 과정을 통해 클라이언트에게 전달된다.&lt;/p&gt;
&lt;p&gt;URI mapping template에서 사용하는 요소는 다음과 같다:&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;&lt;code&gt;cu&lt;/code&gt;: coap URI&lt;/li&gt;
&lt;li&gt;&lt;code&gt;su&lt;/code&gt;: coaps URI&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tu&lt;/code&gt;: &lt;code&gt;cu&lt;/code&gt; or &lt;code&gt;su&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt;: &quot;coap&quot; or &quot;coaps&quot;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hp&lt;/code&gt;: host [&quot;:&quot; port]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt;: path-abempty&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q&lt;/code&gt;: query&lt;/li&gt;
&lt;li&gt;&lt;code&gt;qq&lt;/code&gt;: [&quot;?&quot; query] where &lt;code&gt;qq&lt;/code&gt; is empty iff 'query' is empty&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예로 base URI와 target CoAP URI가 다음과 같을 때,&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;base URI: &lt;a href=&quot;http://p.example.com/hc&quot;&gt;http://p.example.com/hc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;target CoAP URI: coap://s.example.com/light, or coaps://s.example.com/light&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;hosting HTTP URI는 template에 따라 다음과 같이 조합할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;vim&quot;&gt;&lt;code&gt;'?coap_target_uri={+cu}'
    http://p.example.com/hc?coap_target_uri=coap://s.example.com/light
    http://p.example.com/hc?coap_target_uri=s.example.com/light
'?coaps_target_uri={+su}'
    http://p.example.com/hc?coaps_target_uri=coaps://s.example.com/light
'?target_uri={+tu}'
    http://p.example.com/hc?target_uri=coap://s.example.com/light
    http://p.example.com/hc?target_uri=coaps://s.example.com/light
'/{+tu}'
    http://p.example.com/hc/coap://s.example.com/light
    http://p.example.com/hc/coaps://s.example.com/light
'{+s}{+hp}{+p}{+qq}'
    http://p.example.com/hc/coap/s.example.com/light
    http://p.example.com/hc/coap/s.example.com/light?on
'?s={+s}&amp;amp;hp={+hp}&amp;amp;p={+p}&amp;amp;q={+q}'
    http://p.example.com/hc?s=coap&amp;amp;hp=s.example.com&amp;amp;p=light&amp;amp;q=
    http://p.example.com/hc?s=coap&amp;amp;hp=s.example.com&amp;amp;p=light&amp;amp;q=on&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2. Discovery&lt;/h2&gt;
&lt;p&gt;CoAP을 지원하는 센서에서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc6690&quot;&gt;CoRE Link Format&lt;/a&gt;에 따라 자신의 리소스 정보를 제공한다. 본 draft에서는 여기에 맞춰 HC proxy 정보를 제공할 수 있는 resource type과 target attribute를 추가 정의하였다.&lt;/p&gt;
&lt;p&gt;센서에서 이용 가능한 HC proxy 정보는 &lt;code&gt;core.hc&lt;/code&gt; resource type을 새로 정의하여 제공한다.&lt;/p&gt;
&lt;pre class=&quot;pf&quot;&gt;&lt;code&gt;Req: GET coap://\[ff02::1\]/.well-known/core?rt=core.hc
Res: 2.05 Content
     &amp;lt;/hc&amp;gt;;anchor=&quot;http://p.example.com&quot;;rt=&quot;core.hc&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hct&lt;/code&gt; target attribute를 추가하여 URI mapping template 정보를 명시적으로 클라이언트에게 전달할 수도 있다.&lt;/p&gt;
&lt;pre class=&quot;pf&quot;&gt;&lt;code&gt;Req: GET coap://\[ff02::1\]/.well-known/core?rt=core.hc
Res: 2.05 Content
     &amp;lt;/hc&amp;gt;;anchor=&quot;http://p.example.com&quot;;rt=&quot;core.hc;hct={+tu}&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HC proxy의 HTTP 측으로는 클라이언트에게 아래와 같이 proxy 접근 정보를 제공할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;dts&quot;&gt;&lt;code&gt;Req: GET /.well-known/core?rt=core.hc HTTP/1.1
     Host: p.example.com
Res: HTTP/1.1 200 OK
     Content-Type: application/link-format
     Content-Length: 18
     &amp;lt;/hc&amp;gt;;rt=&quot;core.hc&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아래는 link format 정보를 JSON 형식으로 제공하는 예이다.&lt;/p&gt;
&lt;pre class=&quot;groovy&quot;&gt;&lt;code&gt;Req: GET /.well-known/core?rt=core.hc HTTP/1.1
     Host: p.example.com
Res: HTTP/1.1 200 OK
     Content-Type: application/link-format+json
     Content-Length: 31
     [{&quot;href&quot;:&quot;/hc&quot;, &quot;rt&quot;:&quot;core.hc&quot;}]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HTTP payload 대신 Link 헤더에 실어 보낸 경우이다.&lt;/p&gt;
&lt;pre class=&quot;dts&quot;&gt;&lt;code&gt;Req: GET /.well-known/core?rt=core.hc HTTP/1.1
     Host: p.example.com
Res: HTTP/1.1 200 OK
     Link: &amp;lt;/hc&amp;gt;;rt=&quot;core.hc&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;또는 아래와 같이 coap 또는 coaps에 따라 두 개의 다른 base URI를 노출할 수도 있다.&lt;/p&gt;
&lt;pre class=&quot;http&quot;&gt;&lt;code&gt;Req: GET /.well-known/core?rt=core.hc HTTP/1.1
     Host: p.example.com
Res: HTTP/1.1 200 OK
     Content-Type: application/link-format+json
     Content-Length: 111

     [
       {&quot;href&quot;:&quot;/hc/plaintext&quot;, &quot;rt&quot;:&quot;core.hc&quot;, &quot;hct&quot;:&quot;{+cu}&quot;},
       {&quot;href&quot;:&quot;/hc/secure&quot;, &quot;rt&quot;:&quot;core.hc&quot;, &quot;hct&quot;:&quot;{+su}&quot;}
     ]&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3. Media type mapping&lt;/h2&gt;
&lt;p&gt;HTTP의 &lt;code&gt;Content-Type&lt;/code&gt; 및 &lt;code&gt;Content-Encoding&lt;/code&gt; 헤더의 값과 CoAP의 &lt;code&gt;Content-Format&lt;/code&gt; 옵션 값 사이의 변환, 그리고 HTTP의 &lt;code&gt;Accept&lt;/code&gt; 및 &lt;code&gt;Accept-Encoding&lt;/code&gt; 헤더의 값과 CoAP &lt;code&gt;Accept&lt;/code&gt; 옵션 값 사이의 변환을 포함한다.&lt;/p&gt;
&lt;p&gt;서로 정확하게 1:1 변환이 되면 좋겠지만, 앞에서 보다시피 HTTP의 두 개 헤더를 CoAP의 한 개 옵션과 mapping해야 하고, HTTP 쪽은 이미 1000개가 넘는 media type이 등록되어 있는 반면에 CoAP 쪽은 10개도 채 안되기 때문에 기계적인 변환이 어렵다. 변환 메카니즘을 구성하는데 필요한 요소는 다음과 같다.&lt;/p&gt;
&lt;h3&gt;Tight/Loose coupling&lt;/h3&gt;
&lt;p&gt;tight coupling 방식은 말 그대로 정확히 일치하는 HTTP internet media type과 CoAP content format 사이의 변환만 진행하는 것이다. 반면 loose coupling은 비슷한 부류끼리 일반화된 media type으로 묶은 뒤 그에 맞는 CoAP content format으로 변환하는 것이다. 다음 표는 그 예이다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/c1tJCU/btqxCPttIVH/W3eqQDSbXrYz7uCLmBsom1/img.png' data-lightbox='lightbox' data-alt='Media type generalization lookup table'&gt;&lt;img src='https://k.kakaocdn.net/dn/c1tJCU/btqxCPttIVH/W3eqQDSbXrYz7uCLmBsom1/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fc1tJCU%2FbtqxCPttIVH%2FW3eqQDSbXrYz7uCLmBsom1%2Fimg.png' width=&quot;407&quot; height=&quot;133&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Media type generalization lookup table&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;Media type to Content format mapping algorithm&lt;/h3&gt;
&lt;p&gt;HTTP의 &lt;code&gt;Content-Type&lt;/code&gt;, &lt;code&gt;Content-Encoding&lt;/code&gt; 헤더 값을 갖고 fail 처리 혹은 CoAP &lt;code&gt;Content-Format&lt;/code&gt;으로 변환하기 위한 동작 알고리즘을 명시한다. 위에서 설명한 generalized media type 표를 통한 loose coupling도 포함하고 있다. 알고리즘 자체는&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-core-http-mapping-07&quot;&gt;draft&lt;/a&gt; 6.4절에 도시된 내용으로 대신한다.&lt;/p&gt;
&lt;p&gt;알고리즘은 완벽한 1:1 변환을 보장해주지 않으며, 일부 type 정보의 유실이나 다른 일반화된 type으로의 변환 등 side effect 문제를 포함하고 있다.&lt;/p&gt;
&lt;h3&gt;Content transcoding&lt;/h3&gt;
&lt;p&gt;선택적으로 적용 가능한 것으로, 가령 XML을 EXI (efficient XML interchange)로 대체하거나 JSON을 CBOR (concise binary object representation)으로 바꾸는 등 서로 호환되면서 동일 내용을 보다 효율적으로 전송할 수 있는 content format으로 대체하는 것을 말한다. 이 또한 앞서 언급한 side effect 문제를 일으키는 원인 중 하나다.&lt;/p&gt;
&lt;h3&gt;Unrecognized value&lt;/h3&gt;
&lt;p&gt;만약 HTTP internet media type을 CoAP content format으로 변환하는데 실패한 경우, HTTP &lt;code&gt;415 Unsupported Media Type&lt;/code&gt;으로 반송한다.&lt;/p&gt;
&lt;p&gt;반대로 HC proxy에서 수신한 CoAP 메시지의 content format이 인식할 수 없는 값이면 HTTP 메시지의 &lt;code&gt;Content-Type&lt;/code&gt; 헤더에 'application/coap-payload' type으로 설정하고 여기에 &lt;code&gt;cf&lt;/code&gt; 파라미터를 추가하여 CoAP &lt;code&gt;Content-Format&lt;/code&gt; 옵션 값을 같이 보낼 수 있다.&lt;/p&gt;
&lt;pre class=&quot;stata&quot;&gt;&lt;code&gt;Content-Type: application/coap-payload;cf=60&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;4. Response code mapping&lt;/h2&gt;
&lt;p&gt;다음 표 하나로 설명을 대체할 수 있을 듯 하다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bO386K/btqxDTIEXuK/abJ8uIIyZtyYw3z89eQAu0/img.png' data-lightbox='lightbox' data-alt='CoAP-HTTP Response Code Mappings'&gt;&lt;img src='https://k.kakaocdn.net/dn/bO386K/btqxDTIEXuK/abJ8uIIyZtyYw3z89eQAu0/img.png' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbO386K%2FbtqxDTIEXuK%2FabJ8uIIyZtyYw3z89eQAu0%2Fimg.png' width=&quot;519&quot; height=&quot;390&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;CoAP-HTTP Response Code Mappings&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;note:&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;반드시 CoAP payload를 같이 보내야 한다.&lt;/li&gt;
&lt;li&gt;PUT, POST, DELETE에 대한 응답은 200으로, 그 외에는 204로 보낸다.&lt;/li&gt;
&lt;li&gt;HTTP conditional request에 대해 CoAP 2.04 응답이 온 경우에 304로 응답한다.&lt;/li&gt;
&lt;li&gt;HTTP conditional request가 아니고ETag헤더를 포함할 때.&lt;/li&gt;
&lt;li&gt;WWW-Authenticate헤더를 포함해야 한다.&lt;/li&gt;
&lt;li&gt;CoAP 4.02를 받으면 proxy는 HTTP 400 응답으로 바꿔 보내기 전에 우선 옵션 몇 개를 생략하고 다시 CoAP 요청을 시도해야 한다. HTTP 402 응답 코드를 사용하면 안된다.&lt;/li&gt;
&lt;li&gt;CoAP 4.05는 반드시 HTTP 400으로 바꿔야 한다.&lt;/li&gt;
&lt;li&gt;HTTPRetry-After헤더 값은 CoAPMax-Age옵션으로부터 얻는다.&lt;/li&gt;
&lt;li&gt;CoAP 5.05는 proxy가 forward proxy일 때만 발생되어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;5. Cache &amp;amp; congestion control, etc.&lt;/h2&gt;
&lt;p&gt;본 절에서는 &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-core-http-mapping-07&quot;&gt;draft&lt;/a&gt;의 8장 Additional Mapping Guidelines 내용의 일부만 소개한다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;만약 HTTP 연결 타임아웃으로 인해 HTTP 클라이언트에서 연결을 종료해도, HC proxy에서는 CoAP 응답이 수신될 때까지 기다렸다가 cache에 저장할 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;HC proxy에서는 혼잡 제어를 위해 CoAP 서버 별로 동시 &lt;code&gt;NSTART&lt;/code&gt; 이내로 요청을 제한해야 한다. 이 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7252&quot;&gt;CoAP&lt;/a&gt;RFC에 기본으로 &lt;code&gt;1&lt;/code&gt;로 정의되어 있다. 또한 전체 센서 망에 유입되는 동시 CoAP request 수를 제한해야 하며 이를 위해 queueing 또는 drop 시키고 '503 Service Unavailable' HTTP 응답을 보내는 것으로 처리한다.&lt;/li&gt;
&lt;li&gt;HC proxy는 HTTP payload가 &lt;code&gt;BLOCKWISE_THRESHOLD&lt;/code&gt; 보다 클 경우 blockwise 방식에 기반하여 전송한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BLOCKWISE_THRESHOLD&lt;/code&gt;는 다양한 방법으로 결정되는데, CoAP 서버용 UDP 버퍼 크기, link-layer frame size, IP MTU 크기, 또는 path MTU 크기가 그 대상이 될 수 있다.&lt;/li&gt;
&lt;/ol&gt;</description>
<category>기술</category>
<category>coap</category>
<category>IoT</category>
<category>Proxy</category>
<author>devage</author>
<guid>https://devage.tistory.com/44</guid>
<comments>https://devage.tistory.com/44#entry44comment</comments>
<pubDate>Wed, 21 Aug 2019 11:49:34 +0900</pubDate>
</item>
<item>
<title>First-Class Procedure in C</title>
<link>https://devage.tistory.com/43</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2014.12.09에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sicp2014 스터디에 참여하면서 first-class procedure (function)에 대해 공부하게 되었는데, 여기에 그 내용을 올린다. 먼저, SICP 책에서 first-class procedure는 다음 4가지로 정리된다.&lt;/p&gt;
&lt;h2&gt;정의 (SICP 1.3절 (pp.98))&lt;/h2&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;변수의 값이 될 수 있다. 다시 말해, 이름이 붙을 수 있다.&lt;/li&gt;
&lt;li&gt;프로시저 인자로 쓸 수 있다.&lt;/li&gt;
&lt;li&gt;프로시저의 결과로 만들어질 수 있다.&lt;/li&gt;
&lt;li&gt;데이터 구조 속에 집어 넣을 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;C Implementation&lt;/h2&gt;
&lt;p&gt;C 언어의 함수는 위 요구사항들을 어떻게 만족시킬 수 있을까? 함수 포인터가 알파요 오메가다.&lt;/p&gt;
&lt;h3&gt;변수의 값으로 사용&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;&lt;code&gt;typedef int (*operator_f)(int, int);

int my_mul(int a, int b)
{
  return (a*b);
}

int main(void)
{
  operator_f mul = my_mul; // (1)
  int a = 4, b = 5;
  printf(&quot;%d x %d = %d\n&quot;, a, b, mul(a, b));
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;프로시저의 인자로 사용&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;&lt;code&gt;typedef int (*operator_f)(int, int);

int my_mul(int a, int b)
{
  return (a*b);
}

int op(int a, int b, operator_f operation)
{
  return operation(a, b);
}

int main(void)
{
  int a = 4, b = 5;
  printf(&quot;%d x %d = %d\n&quot;, a, b, op(a, b, my_mul)); // (2)
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;프로시저의 결과로 받기&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;&lt;code&gt;typedef int (*operator_f)(int, int);

int my_mul(int a, int b)
{
  return (a*b);
}

operator_f get_op_mul(void)
{
  return my_mul; // (3)
}

int main(void)
{
  int a = 4, b = 5;
  printf(&quot;%d x %d = %d\n&quot;, a, b, get_op_mul()(a, b));
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;데이터 구조 속에 집어 넣기&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;&lt;code&gt;typedef int (*operator_f)(int, int);

typedef struct {
  int a;
  int b;
  operator_f op;
} calc_t;

int my_mul(int a, int b)
{
  return (a*b);
}

int main(void)
{
  calc_t calc = { 4, 5, my_mul };
  printf(&quot;%d x %d = %d\n&quot;, calc.a, calc.b, calc.op(calc.a, calc.b));
  return 0;
}&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;기타&lt;/h3&gt;
&lt;p&gt;SICP에서 first-class procedure의 조건을 정의한 이후로, 함수형 언어에 대한 연구가 계속 이어져 오면서 몇 가지 조건들이 더 추가되었다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;중첩된 합수 정의&lt;/li&gt;
&lt;li&gt;익명 함수&lt;/li&gt;
&lt;li&gt;클로저 (closure)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C 언어는 위 조건들을 충족하지 못한다. 최신 C 언어 표준인 C11에서도 포함되어 있지 않다.&lt;br /&gt;다만 OS X의 clang에서는 block의 형태로 closure를 지원한다. 아래 코드는 영문판 wikipedia에 있는 것이다.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;Block.h&amp;gt;

typedef int (^IntBlock)();

IntBlock MakeCounter(int start, int increment)
{
  __block int i = start;

  return Block_copy(^{
      int ret = i;
      i += increment;
      return ret;
    });
}

int main(void)
{
  IntBlock mycounter = MakeCounter(5, 2);
  printf(&quot;1st call: %d\n&quot;, mycounter());
  printf(&quot;2nd call: %d\n&quot;, mycounter());
  printf(&quot;3rd call: %d\n&quot;, mycounter());

  Block_release(mycounter);

  return 0;
}&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>FP</category>
<category>SICP</category>
<author>devage</author>
<guid>https://devage.tistory.com/43</guid>
<comments>https://devage.tistory.com/43#entry43comment</comments>
<pubDate>Wed, 21 Aug 2019 11:26:39 +0900</pubDate>
</item>
<item>
<title>cider eval customization</title>
<link>https://devage.tistory.com/42</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2014.12.09에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://eigenhombre.com/emacs-customization-for-clojure.html&quot;&gt;emacs customization for clojure&lt;/a&gt;에, 코드에 eval 결과를 삽입하여 lighttable의 instarepl과 같은 효과를 주는 함수가 있는데 지금 사용해보니 그 사이에 cider에서 삭제된 함수 때문에 사용할 수 없었다. 다음과 같은 오류 메시지가 발생한다.&lt;/p&gt;
&lt;pre class=&quot;ada&quot;&gt;&lt;code&gt;Symbol's function definition is void: cider-eval-and-get-value&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음은 수정한 함수이다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;;; new version
(defun cider-eval-last-sexp-and-append ()
  &quot;Evaluate the expression preceding point and append result.&quot;
  (interactive)
  (let ((last-sexp (cider-last-sexp)))
    ;; we have to be sure the evaluation won't result in an error
    (cider-eval-last-sexp)
    (with-current-buffer (current-buffer)
                         (insert &quot;;;=&amp;gt; &quot;))
    (cider-interactive-eval last-sexp
                            (cider-eval-print-handler))))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고용으로, 원 소스도 같이 올려둔다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;;; original version
(defun cider-eval-last-sexp-and-append ()
  &quot;Evaluate the expression preceding point and append result.&quot;
  (interactive)
  (let ((last-sexp (cider-last-sexp)))
    ;; we have to be sure the evaluation won't result in an error
    (cider-eval-and-get-value last-sexp)
    (with-current-buffer (current-buffer)
                         (insert &quot;;;=&amp;gt; &quot;))
    (cider-interactive-eval-print last-sexp)))&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>clojure</category>
<category>emacs</category>
<category>REPL</category>
<author>devage</author>
<guid>https://devage.tistory.com/42</guid>
<comments>https://devage.tistory.com/42#entry42comment</comments>
<pubDate>Wed, 21 Aug 2019 11:21:52 +0900</pubDate>
</item>
<item>
<title>node.js에서 iconv로 인코딩 변경 시 유의점</title>
<link>https://devage.tistory.com/41</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2014.04.03에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;node.js&lt;/code&gt; 연습 겸 &lt;a href=&quot;http://off.aladin.co.kr&quot;&gt;알라딘 오프라인 중고서점&lt;/a&gt;으로부터 책 검색하는 짧은 코드를 작성하고 있는데, 알라딘 사이트가 utf-8이 아닌 euc-kr 인코딩을 사용하고 있어서 한글이 깨지는 문제가 있었다.&lt;br /&gt;웹에서 찾아본 대로 &lt;code&gt;iconv&lt;/code&gt;를 이용해 인코딩 변환 코드를 추가했는데 (늘 그렇듯이) 한번에 성공이 안되는 것이다.&lt;/p&gt;
&lt;p&gt;약간의 우여곡절 끝에 해결할 수 있었는데, 웹 검색했을 때에는 달리 나오지 않는 문제라서, 나한테만 해당되는 특수한 상황일 수 있다. 하여튼 시행착오를 거쳐 두 가지를 배울 수 있었다.&lt;/p&gt;
&lt;h2&gt;인코딩 변환한 결과를 원래의 문자열 변수에 넣지 말자&lt;/h2&gt;
&lt;pre class=&quot;haxe&quot;&gt;&lt;code&gt;var Iconv = require('iconv').Iconv;
// ...
var iconv = new Iconv('euc-kr', 'utf-8//translit//ignore');
searchResult = iconv.convert(searchResult).toString('utf-8');&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;코드 중 &lt;code&gt;//translit//ignore&lt;/code&gt;는 인코딩 변환 과정 중에 이해할 수 없는 값이 입력됐을 경우 이를 어떻게든 바꾸거나 ('어떻게'인지는 잘 모른다) 아니면 무시하라고 알리는 것이다.&lt;br /&gt;보통 웹에서 인코딩 변환 문제로 찾아보면 대부분 포함되어 있는데 이게 없으면 &quot;Illegal character sequence&quot; 에러를 내고 죽는다.&lt;br /&gt;보통 입력 내용 중에 utf-8 데이터가 섞여있을 경우에 종종 발생한다고 하는데 마지막 라인 좌항의 &lt;code&gt;searchResult&lt;/code&gt;를 &lt;code&gt;searchResultUtf8&lt;/code&gt; 식의 별도의 변수를 사용하니 피할 수 있었다.&lt;/p&gt;
&lt;p&gt;내 생각으로는 &lt;code&gt;iconv.convert()&lt;/code&gt; 함수가 입력을 받은 후 변환 결과를 제 3의 메모리 공간에 저장한 후 이를 반환하는 것일 거라고 짐작했었는데 바로 입력 공간(&lt;code&gt;searchResult&lt;/code&gt;)에다 write 하는 것이었던 듯.&lt;/p&gt;
&lt;p&gt;다음은 수정한 코드.&lt;/p&gt;
&lt;pre class=&quot;haxe&quot;&gt;&lt;code&gt;var Iconv = require('iconv').Iconv;
// ...
var iconv = new Iconv('euc-kr', 'utf-8');
var searchResultUtf8 = iconv.convert(searchResult).toString('utf-8');&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;인코딩 변환 전에 한번 &lt;code&gt;Buffer&lt;/code&gt; 형의 버퍼에 넣어주자&lt;/h2&gt;
&lt;p&gt;죽지 않고 인코딩에 성공했는데, 그 결과가 '쨈쨈쨋짝...' 식으로 이상하게 깨져나왔다. 이건 &lt;a href=&quot;https://namu.wiki/w/%E5%8D%A0%EC%8F%99%EC%98%99&quot;&gt;占쏙옙&lt;/a&gt;과는 다른 문제이다.&lt;/p&gt;
&lt;p&gt;이유는 모르겠지만, &lt;code&gt;Buffer&lt;/code&gt; 형 변수에 한번 넣어주는 것으로 해결했다.&lt;/p&gt;
&lt;pre class=&quot;haxe&quot;&gt;&lt;code&gt;var Iconv = require('iconv').Iconv;
// ...
var iconv = new Iconv('euc-kr', 'utf-8');
var searchResultBin = new Buffer(searchResult, 'binary');
var searchResultUtf8 = iconv.convert(searchResultBin).toString('utf-8');&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이미 한번 &lt;code&gt;searchResultBin&lt;/code&gt;에 담았으므로, 이 경우 &lt;code&gt;iconv.convert()&lt;/code&gt; 결과를 다시 &lt;code&gt;searchResult&lt;/code&gt;에 담아도 무방할 것 같다.&lt;/p&gt;</description>
<category>기술</category>
<category>EUC-KR</category>
<category>iconv</category>
<category>node.js</category>
<category>Unicode</category>
<category>UTF-8</category>
<author>devage</author>
<guid>https://devage.tistory.com/41</guid>
<comments>https://devage.tistory.com/41#entry41comment</comments>
<pubDate>Wed, 21 Aug 2019 11:18:30 +0900</pubDate>
</item>
<item>
<title>Racket으로 SICP 공부하기</title>
<link>https://devage.tistory.com/40</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2014.03.13에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;약간만 구글링하면 금방 알 수 있는 바와 같이, SICP도 프로그래밍 능력을 한단계 업그레이드할 수 있는 좋은 책이고 clojure도 최근 함수형 언어 중에서 주목받고 있는 언어이다. 다만 SICP를 공부하려면 scheme이라는 lisp의 한 갈래인 언어로 익혀야 하는데, scheme 보다는 clojure를 공부하고 싶어서 이왕에 두 마리 토끼를 잡는다는 생각으로 clojure로 SICP 공부를 하고 있었다.&lt;/p&gt;
&lt;p&gt;하면서 보니 이 방법에 몇몇 문제점이 있다는 것을 알았는데, 하나는 SICP 책을 보면서 머리 속에서 scheme과 clojure 사이에 변환을 해야 하다보니 진도가 잘 나가지 않는다는 점이고, 다른 하나는 &lt;code&gt;new-if&lt;/code&gt; 예제나 &lt;code&gt;tail-recursive&lt;/code&gt; 예제처럼 scheme과 clojure의 차이 때문에 clojure로 코드를 바꿀 때 clojure의 특성을 같이 고려해서 반영해줘야 하는 점이 있었다.&lt;/p&gt;
&lt;p&gt;그래서 scheme을 통해 책을 먼저 훑어보고 그 후 clojure를 통해 연습문제를 푸는 방법이 좋을 것 같다. SICP의 scheme 코드를 실행해보기 위해서는 &lt;a href=&quot;http://www.racket-lang.org/&quot;&gt;racket&lt;/a&gt;과 그 개발환경인 DrRacket이 딱 안성맞춤이라고 생각한다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.racket-lang.org/&quot;&gt;racket&lt;/a&gt;은 Mac OS X, Linux, Windows 등을 지원하므로 다운로드 및 설치는 홈페이지를 참고하면 되고, 설치 후 몇 가지 환경 설정을 해주어야 할 것들이 있다. 여기에 대해서는 &lt;a href=&quot;http://wiki.reeseo.net/Racket&quot;&gt;Reeseo.net Wiki&lt;/a&gt;에서 다음과 같은 항목들에 대해 자세히 다루고 있으므로 링크 내용을 참고하면 된다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;Racket용 SICP 명세 모듈 설치&lt;/li&gt;
&lt;li&gt;SICP 명세를 기본값으로 설정&lt;/li&gt;
&lt;li&gt;출력 스타일 수정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;디버깅도 가능해서, 각 구문을 단계적으로 진행해가면서 구문의 반환값을 확인할 수 있으며, 스택 내용도 볼 수 있다.&lt;/p&gt;
&lt;p&gt;SICP 1.2.2 절의 &lt;a href=&quot;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%25_sec_1.2.2&quot;&gt;피보나치 수열의 tree recursion&lt;/a&gt;에 있는 재귀 버전 코드나 반복 버전 코드를 입력한 후 실행한 다음, 디버그 버튼을 누르면 디버깅을 위한 요소를 볼 수 있다. 특히 스택 내용을 보면 재귀와 반복 버전 간의 차이를 쉽게 알 수 있을 것이다.&lt;/p&gt;</description>
<category>기술</category>
<category>racket</category>
<category>scheme</category>
<category>SICP</category>
<author>devage</author>
<guid>https://devage.tistory.com/40</guid>
<comments>https://devage.tistory.com/40#entry40comment</comments>
<pubDate>Wed, 21 Aug 2019 11:10:30 +0900</pubDate>
</item>
<item>
<title>Clojure로 텍스트의 문자 수 세기</title>
<link>https://devage.tistory.com/39</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2013.04.03에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;지난 번에 작성한 것은 단순히 '가'부터 '힣'까지 차례로 출력하는 코드였다.&lt;br /&gt;이번에는 저장된 웹페이지로부터 한글 유니코드만 읽어들여 각 문자 별로 몇 개 발생했는 지 그 수를 세는 코드를 작성한다.&lt;/p&gt;
&lt;p&gt;다음은 file.html에 저장된 파일 내용을 읽어들여 그 중에서 한글 유니코드만 시퀀스로 만들어주는 코드이다.&lt;br /&gt;&lt;code&gt;slurp&lt;/code&gt;는 파일을 읽어들여 그 내용을 리스트로 만들어주는 함수로, 아주 큰 파일(한도가 얼마인 지는 세보지 못했다)만 아니면 유용하게 사용할 수 있다고 한다.&lt;br /&gt;파일 경로 뿐 아니라 http url을 넣어주면 바로 웹 페이지를 읽어들일 수도 있다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(filter
  (fn [x] (and (&amp;gt;= (int x) (int \가)) (&amp;lt;= (int x) (int \힣))))
  (slurp &quot;/somewhere/in/file.html&quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음은 각 문자 별로 발생 갯수를 세서 더하는 함수로, 아직 clojure 실력이 미천하다 보니(...) 어떻게 작성할까 검색하다가 발견한 코드이다. 다음은 &lt;a href=&quot;http://clojuredocs.org/clojure.core/update-in&quot;&gt;clojuredocs&lt;/a&gt;의 &lt;code&gt;update-in&lt;/code&gt; 예제 코드에서 사용된 함수이다. 1.2.0부터 지원하는 함수인 듯 하다.&lt;br /&gt;&lt;code&gt;fnil&lt;/code&gt;도 같이 봐두면 좋다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn char-cnt  [s]
  &quot;Counts occurrence of each character in s&quot;
  (reduce
    (fn  [m k]
      (update-in m  [k]  (fnil inc 0)))
    {}
    (seq s)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;char-cnt&lt;/code&gt; 함수를 돌린 결과는 다음과 같다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(char-cnt (filter
  (fn [x] (and (&amp;gt;= (int x) (int \가)) (&amp;lt;= (int x) (int \힣))))
  (slurp &quot;/somewhere/in/file.html&quot;)))
{\가 86, \저 9, \퀀 1, \될 7, \낀 1, \좀 3, \풀 1, \겠 2, ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기에 sort까지 해주면 모양새가 더 좋겠지만 이번에 하려는 작업에서는 필요 없기 때문에 생략.&lt;/p&gt;</description>
<category>기술</category>
<category>clojure</category>
<author>devage</author>
<guid>https://devage.tistory.com/39</guid>
<comments>https://devage.tistory.com/39#entry39comment</comments>
<pubDate>Wed, 21 Aug 2019 11:08:07 +0900</pubDate>
</item>
<item>
<title>Clojure로 유니코드 한글 출력하기</title>
<link>https://devage.tistory.com/38</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2013.03.29에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;유니코드 (또는 UTF-8)로 구성된 한글 테이블이 필요해져서, 이왕에 clojure 연습 겸&lt;br /&gt;한글 유니코드를 출력하는 코드를 작성해보았다.&lt;br /&gt;유니코드 테이블에서의 한글의 범위는 &lt;code&gt;\uAC00&lt;/code&gt;~&lt;code&gt;\uD7A3&lt;/code&gt; 까지 11,172자로, 유니코드 한글코드표에서 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;코드는 제일 처음 값부터 시작해서 끝까지 리스트로 출력하는 것으로 작성하면 될 것이다.&lt;br /&gt;대충 다음과 같이 작성하면 쉽게 되지 않을까?&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(range \uac00 \ud7a3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아쉽게도 다음과 같이 에러를 뱉는다. 숫자가 아니라고 한다.&lt;/p&gt;
&lt;pre class=&quot;stylus&quot;&gt;&lt;code&gt;ClassCastException java.lang.Character cannot be cast to java.lang.Number  clojure.lang.Numbers.lt (Numbers.java:219)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그래서 좀더 찾아본 후 다음과 같이 수정했다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(map char (range 0xac00 0xd7a3))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 동작한다! 다음과 같이 첫 값과 마지막 값을 확인할 수 있다.&lt;/p&gt;
&lt;pre class=&quot;clojure-repl&quot;&gt;&lt;code&gt;user=&amp;gt; (first (map char (range 0xac00 0xd7a3)))
\가
user=&amp;gt; (last (map char (range 0xac00 0xd7a3)))
\힢&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;가만, '힢'? 원래 한글 유니코드의 마지막은 '힣'이다. 위 링크의 정보가 잘못된 건가? 이모저모 확인해보니 &lt;code&gt;range&lt;/code&gt;에 넣은 값이 문제였다. 원하는 끝 값보다 하나 더 큰 값으로 넣어야 한다.&lt;br /&gt;&lt;code&gt;(range 0 5)&lt;/code&gt;의 결과는 &lt;code&gt;(0 1 2 3 4)&lt;/code&gt;이다.&lt;/p&gt;
&lt;pre class=&quot;clojure-repl&quot;&gt;&lt;code&gt;user=&amp;gt; (last (map char (range 0xac00 0xd7a4)))
\힣&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;원하는 결과가 나왔다.&lt;/p&gt;</description>
<category>기술</category>
<category>clojure</category>
<category>Korean</category>
<category>Unicode</category>
<author>devage</author>
<guid>https://devage.tistory.com/38</guid>
<comments>https://devage.tistory.com/38#entry38comment</comments>
<pubDate>Wed, 21 Aug 2019 11:02:35 +0900</pubDate>
</item>
<item>
<title>사용해봤거나 사용 중인 렌즈들</title>
<link>https://devage.tistory.com/11</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2004.06.24에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;af-28-80mm-f-3-3-5-6g&quot;&gt;AF 28-80mm F/3.3-5.6G&lt;/h3&gt;
&lt;p&gt;D100을 샀을 때 따라온 번들렌즈. 첫 인상은 '조잡하고 장난감처럼 생겼다'이지만 지금은 최고의 가격 대 성능 비를 보여주는 렌즈로 평가하고 싶다. 'G'라는 표기는 조리개 값 조정을 바디에서만 할 수 있다는 의미다. 따라서 렌즈에는 조리개 링이 생략되어 있다.&lt;br /&gt;줌 경통이 좀 헐렁헐렁하고 망원에서의 최대 개방 조리개 값이 낮은 이유 때문에 바로 깜찍하게 생긴 어느 사진학과(또는 동아리) 여대생에게 중고로 팔았다.&lt;/p&gt;
&lt;h3 id=&quot;af-s-24-85mm-f-3-5-4-5g-if-ed&quot;&gt;AF-s 24-85mm F/3.5-4.5G IF-ED&lt;/h3&gt;
&lt;p&gt;위의 28-80 렌즈와 같은 G 렌즈이지만 격이 다른 놈이다.&lt;br /&gt;'AF-s'는 렌즈 내에 포커스용 초음파 모터가 별도 내장되었다는 뜻이고 'IF'는 포커싱 시 돌아가는 경통이 내부에 있다는 뜻이고, 'ED'는 비구면 수차 렌즈를 사용하여 색수차를 줄였다는 뜻이다. 하지만 소유자의 내공이 약해서인지 위의 28-80 렌즈와의 차이점을 별로 찾지 못했다. 다만 초음파 모터 덕분에 조용히 그리고 빠르게 포커싱을 맞춘다는게 위안이라면 위안이랄까.&lt;br /&gt;한동안 35mm 및 45mm 렌즈 덕에 방에 콕 박혀 있던 렌즈지만, 요즘은 이 렌즈를 끼고 돌아다닌다.&lt;/p&gt;
&lt;h3 id=&quot;af-35mm-f-2d&quot;&gt;AF 35mm F/2D&lt;/h3&gt;
&lt;p&gt;28-80 및 24-85 렌즈의 큼직막한 크기에 질려 구입한 첫 단렌즈. 일반 35mm 필름 카메라에서는 광각에 속하지만 화각을 1.5배 뻥튀기 해주어야 하는 D100에서는 52.5mm로 표준 화각에 근접한 렌즈로 변신해 버린다.&lt;br /&gt;D100에서는 50mm 렌즈 조차도 75mm 준망원이 되기 때문에 실내용으로도 부적합하나, 35mm 렌즈로는 실내든 실외든 어디서나 쉽게 찍을 수 있다. 게다가 광각 렌즈 특유의 왜곡이 적은 것도 표준렌즈를 대체하는 한 요인이 되고 있다.&lt;br /&gt;다만 문제는 조리개날에 기름이 잘 샌다는 것. 그리고 국내에서는 더 이상 팔지 않는다는 것이다. 이 때문에 한번 A/S도 다녀왔고, 많은 사람들이 이 렌즈를 구하기 위해 발품을 팔고 있다.&lt;br /&gt;현재 고이 보관 중. 또 기름 새고 있던데 언제 또 고치나~&lt;/p&gt;
&lt;h3 id=&quot;af-85mm-f-1-8d&quot;&gt;AF 85mm F/1.8D&lt;/h3&gt;
&lt;p&gt;85mm F/1.4D 렌즈와 더불어 인물 사진 용으로 훌륭한 평가를 받는 렌즈.&lt;br /&gt;찍어본 느낌은 '대충 찍어도 잘나온다'였다. 사람은 선명하게, 주위 배경은 흐린 윤곽으로 나오게 하는 '아웃포커싱'이 쉽고, 색감도 선명하게 잘 나와준다.&lt;br /&gt;다만 85mm라는 화각은 실내용으로는 부적합하며 실외에서도 모델과의 거리가 좀 멀어진다는 단점이 있다.&lt;br /&gt;내 경우에는 이 렌즈를 활용하여 점수를 따야 할 사람(이를테면 여친)이 없어서 테스트샷만 몇번 찍고 팔아버렸다.&lt;/p&gt;
&lt;h3 id=&quot;mf-45mm-f-2-8p&quot;&gt;MF 45mm F/2.8P&lt;/h3&gt;
&lt;p&gt;35mm 렌즈로도 휴대하기가 너무 버거워 구입한 렌즈. 두께가 2cm도 안되는 정말 얄딱구리한 렌즈다 (모델명의 'P'가 Pancake라는 뜻이라는 썰도 있다).&lt;br /&gt;이 렌즈는 원래 니콘에서 처음으로 만든 것이 아니라 콘탁스에서 기술을 사와서 만든 것으로 알고 있다. 그래서 이 렌즈로 찍은 사진은 콘트라스트가 강하다 ...라는 얘기가 있으나, 본인의 눈으로는 뭐가 뭔지 모른다.&lt;br /&gt;MF라는 단어에서 보듯이 직접 렌즈를 돌려서 촛점을 맞추어야 하지만, 그 외 광량 계산에 의한 조리개값 설정 등은 알아서 할 수 있는, CPU 내장 렌즈이다 (저 얄딱구리한 두께에 다 들어가 있덴다. 신기신기). 현재는 잠시 줌렌즈 위주로 쓰느라 보관 중이다.&lt;/p&gt;</description>
<category>사진</category>
<category>lens</category>
<category>Nikon</category>
<author>devage</author>
<guid>https://devage.tistory.com/11</guid>
<comments>https://devage.tistory.com/11#entry11comment</comments>
<pubDate>Wed, 21 Aug 2019 10:47:25 +0900</pubDate>
</item>
<item>
<title>VisualVM을 이용한 Garbage Collection 확인</title>
<link>https://devage.tistory.com/37</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2013.03.06에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Programming Clojure 책을 보면서 Clojure 공부를 하고 있던 중, 함수형 프로그래밍 부분에서 피보나치 수열을 이용하여 재귀 프로그래밍 및 지연 연산 관련 내용을 다루면서 성능 별로 몇 가지 버전을 다루고 있길래 마침 귀에 들어온 VisualVM이라는 자바 모니터링 툴을 통해 Garbage Collection이 되는 모습을 직접 보기로 했습니다.&lt;/p&gt;
&lt;p&gt;내용 자체는 별 것 없습니다. 그냥 '무겁게 돌아가는 걸 보니 진짜 무겁게 돌아가네'라는, 당연한 것을 확인한 수준이라... 그냥 Clojure 공부 겸 VisualVM 체험 학습 정도로만 봐주시기 바랍니다.&lt;/p&gt;
&lt;p&gt;피보나치 수열 구하는 함수 중에 힙 메모리를 많이 잡아먹는 &lt;code&gt;stack-consuming-fibo&lt;/code&gt;를 돌려봤습니다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(stack-consuming-fibo 45)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;나온 그래프는 아래와 같습니다. 붉은 색 박스 구간이 위 함수를 실행한 때입니다.&lt;/p&gt;
&lt;p&gt;VisualVM 통한 GC 확인&lt;/p&gt;
&lt;p&gt;위 그림의 아래 그래프는 힙 메모리 사용량으로, 서서히 증가하다가 일정 수준에 도달하면 GC 작업에 의해 다시 리셋되는 것을 확인할 수 있습니다. 아래 그래프는 GC 동작 자체를 나타내는 그래프입니다. 함수를 실행하면 힙 메모리 사용량이 급증하면서 수시로 GC가 실행되고 힙 메모리가 리셋되는 것을 확인할 수 있습니다. 위 예에서는 45번째 수열 값을 구하라고 했는데, 50번째 수열을 구하려 했더니 안멈추더군요 :)&lt;/p&gt;
&lt;p&gt;참고로, Programming Clojure 책에서는 무척 큰 값 (1000000000) 을 넣어도 결과값을 얻어내던데, 제가 직접 돌렸더니 92번째 수열 값부터는 결과 값이 정수 값 범위를 벗어났다면서 튕기더군요. 이유는 모르겠습니다. Clojure 버전에 따라 다르게 동작한 것 같은데... (저는 1.4.0 또는 1.5.0을 사용하고 있습니다)&lt;/p&gt;
&lt;p&gt;그래서 아래와 같이 명시적으로 Big Number로 지정해주면 실행됩니다. 다만 결과 값도 끝에 'N'이 붙어서 별로 안 이쁩니다.&lt;/p&gt;
&lt;pre class=&quot;clojure&quot;&gt;&lt;code&gt;(defn stack-consuming-fibo [n]
  (cond
    (= n 0N) 0N
    (= n 1N) 1N
    :else  (+ (stack-consuming-fibo  (- n 1N))
              (stack-consuming-fibo  (- n 2N)))))

(defn recur-fibo [n]
  (letfn  [(fib
             [current next n]
              (if  (zero? n)
               current
                (recur next  (+ current next)  (dec n))))]
    (fib 0N 1N n)))

(defn lazy-seq-fibo
  ([]
   (concat [0N 1N] (lazy-seq-fibo 0N 1N)))
   ([a b]
    (let [n (+ a b)]
     (lazy-seq
        (cons n (lazy-seq-fibo b n))))))

(defn fibo []
  (map first  (iterate  (fn  [[a b]] [b (+ a b)]) [0N 1N])))&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>clojure</category>
<category>GC</category>
<category>visualvm</category>
<author>devage</author>
<guid>https://devage.tistory.com/37</guid>
<comments>https://devage.tistory.com/37#entry37comment</comments>
<pubDate>Wed, 21 Aug 2019 02:15:15 +0900</pubDate>
</item>
<item>
<title>UINT_PTR type</title>
<link>https://devage.tistory.com/30</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2007.11.13에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;64비트 호환 프로그래밍을 위해 &lt;code&gt;_PTR&lt;/code&gt; 접미사 (type for pointer precision의 뜻)가 붙는 형들이 새로 정의되었다는 것을 알았다.&lt;br /&gt;포인터 연산을 위해 포인터 변수를 정수형 변수로 type casting 할 때 발생하는 문제를 해결하기 위해 도입된 듯. 이 중 &lt;code&gt;UINT&lt;/code&gt;의 &lt;code&gt;_PTR&lt;/code&gt; 형인 &lt;code&gt;UINT_PTR&lt;/code&gt; 형은 다음과 같이 정의되어 있다.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;&lt;code&gt;#if defined(_WIN64)
    typedef unsigned __int64 UINT_PTR;
#else
    typedef unsigned int UINT_PTR;
#endif&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;원래 이걸 찾게 된 이유는 &lt;code&gt;SOCKET&lt;/code&gt; 형의 정체가 &lt;code&gt;UINT_PTR&lt;/code&gt; 형이었기 때문이다.&lt;/p&gt;
&lt;pre class=&quot;objectivec&quot;&gt;&lt;code&gt;// winsock2.h:
typedef UINT_PTR SOCKET;&lt;/code&gt;&lt;/pre&gt;</description>
<category>기술</category>
<category>64bit</category>
<category>Windows</category>
<author>devage</author>
<guid>https://devage.tistory.com/30</guid>
<comments>https://devage.tistory.com/30#entry30comment</comments>
<pubDate>Wed, 21 Aug 2019 01:43:14 +0900</pubDate>
</item>
<item>
<title>IPv6 server와 IPv4 또는 IPv6 client 간의 연결</title>
<link>https://devage.tistory.com/26</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2004.10.26에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;전에 졸업해서 나간 연구실 후배로부터 전화가 왔다. 'server에서 하나의 listening socket으로 IPv4 client로부터의 접속과 IPv6 client로부터의 접속을 모두 받아들일 수 있으려면 어떻게 해야 하느냐'는 것이었다. 의외로 잘 모르고 있던 문제라 제대로 대답해주지 못했었는데, 후에 UNP 2nd Ed.를 뒤져서 관련 내용을 찾아보았다.&lt;/p&gt;
&lt;p&gt;우선 server는 다음의 조건을 만족해야 한다.&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal;&quot; data-ke-list-type=&quot;decimal&quot;&gt;
&lt;li&gt;server는 IPv4-IPv6 dual-stack host 상에서 동작해야 한다.&lt;/li&gt;
&lt;li&gt;server가 실행되는 host는 IPv4와 IPv6 주소를 모두 할당받아야 한다.&lt;/li&gt;
&lt;li&gt;server는 wildcard 주소(&lt;code&gt;::0&lt;/code&gt;)에 바인딩된 IPv6 listening 소켓을 가지고 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IPv6 client로부터의 접속은 IPv6 패킷을 통해 전송되기 때문에 IPv6 stack을 거쳐 들어온다. IPv4 client로부터 접속할 때는 다음과 같이 동작한다.&lt;/p&gt;
&lt;ul style=&quot;list-style-type: disc;&quot; data-ke-list-type=&quot;disc&quot;&gt;
&lt;li&gt;IPv4 client는 &lt;code&gt;gethostbyname()&lt;/code&gt; 함수를 통해 server의 A와 AAAA 주소 정보를 취득한다. (server가 dual-stack이므로)&lt;/li&gt;
&lt;li&gt;IPv4 client는 AAAA 레코드를 버리고 A 레코드에 있는 주소 정보를 사용하여 server에 IPv4 패킷으로 접속을 시도한다.&lt;/li&gt;
&lt;li&gt;server는 IPv6 socket으로 전송되는 IPv4 패킷을 수신할 경우, 패킷의 IPv4 주소를 IPv4-mapped IPv6 주소로 간주한다.&lt;/li&gt;
&lt;li&gt;IPv4-mapped IPv6 주소에 의한 연결은 IPv6 socket을 통해 연결하되, 패킷의 전송은 IPv4 stack을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/u07eC/btqxEPyEi85/AY3WIN8DkyKv1FuZTJyey0/img.gif' data-lightbox='lightbox' data-alt='from UNP fig. 10.2'&gt;&lt;img src='https://k.kakaocdn.net/dn/u07eC/btqxEPyEi85/AY3WIN8DkyKv1FuZTJyey0/img.gif' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fu07eC%2FbtqxEPyEi85%2FAY3WIN8DkyKv1FuZTJyey0%2Fimg.gif' &gt;&lt;/span&gt;&lt;figcaption&gt;from UNP fig. 10.2&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;</description>
<category>기술</category>
<author>devage</author>
<guid>https://devage.tistory.com/26</guid>
<comments>https://devage.tistory.com/26#entry26comment</comments>
<pubDate>Wed, 21 Aug 2019 01:06:46 +0900</pubDate>
</item>
<item>
<title>체스 기보</title>
<link>https://devage.tistory.com/24</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2004.06.08에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;보통 '기보'라고 하면 흔히 신문에서 자주 보던 기보 그림을 떠올릴 것이다. 바둑 기보는 바둑판 그림에 흑백 돌을 놓은 순서에 따라 숫자를 붙여가며 그린다. 이렇게 하면 대국 내용이 한눈에 들어와 보기는 좋은데 다른 곳에 활용하기가 힘들다. 바둑용 프로그램에 대국 내용을 입력시키기에 이미지 포맷은 부적절하다.&lt;/p&gt;
&lt;p&gt;체스에도 기보가 있는데, 바둑과 달리 이미 셋팅된 말들을 움직이면서 플레이하는 것이기 때문에 위의 기보와 같은 방식으로 하지 않고, 말들의 움직임을 각 말을 나타내는 영문자와 위치를 나타내는 숫자와 문자, 그리고 기타 몇 가지 기호를 써서 나타낸다. white를 아래에 두어 기준으로 잡고, 가로로는 A, B, C, ... 순으로 알파벳을 매기고, 세로로는 1, 2, 3, ... 순으로 숫자를 매겨 좌표로 삼는다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/bo6jfy/btqxEOGuaZx/A3q41qMsU2kIBTJqhCeNpk/img.jpg' data-lightbox='lightbox' data-alt='체스 보드'&gt;&lt;img src='https://k.kakaocdn.net/dn/bo6jfy/btqxEOGuaZx/A3q41qMsU2kIBTJqhCeNpk/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fbo6jfy%2FbtqxEOGuaZx%2FA3q41qMsU2kIBTJqhCeNpk%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;체스 보드&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;그리고 각 말들은 종류에 따라 하나의 영문자로 나타낸다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pawn = &amp;lsquo;P&amp;rsquo; (또는 생략 가능)&lt;/li&gt;
&lt;li&gt;knight = &amp;lsquo;N&amp;rsquo;&lt;/li&gt;
&lt;li&gt;bishop = &amp;lsquo;B&amp;rsquo;&lt;/li&gt;
&lt;li&gt;rook = &amp;lsquo;R&amp;rsquo;&lt;/li&gt;
&lt;li&gt;queen = &amp;lsquo;Q&amp;rsquo;&lt;/li&gt;
&lt;li&gt;king = &amp;lsquo;K&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어 위 그림에서 White 측에서 좌로부터 다섯번째 pawn이 앞으로 두칸 전진했다면, 다음과 같이 기록한다.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;끝날 때까지의 체스 말들의 움직임에 대국 날짜, 대국자, 장소 등의 정보를 추가하여 다음과 같이 한 대국에 대한 완전한 기보를 작성할 수 있다 (PGN 표준 문서에서 발췌).&lt;/p&gt;
&lt;p&gt;[Event &lt;span&gt;&quot;F/S Return Match&quot;&lt;/span&gt;] [Site &lt;span&gt;&quot;Belgrade, Serbia JUG&quot;&lt;/span&gt;] [Date &lt;span&gt;&quot;1992.11.04&quot;&lt;/span&gt;] [Round &lt;span&gt;&quot;29&quot;&lt;/span&gt;] [White &lt;span&gt;&quot;Fischer, Robert J.&quot;&lt;/span&gt;] [&lt;span&gt;Black &lt;/span&gt;&lt;span&gt;&quot;Spassky, Boris V.&quot;&lt;/span&gt;] [Result &lt;span&gt;&quot;1/2-1/2&quot;&lt;/span&gt;] &lt;span&gt;1&lt;/span&gt;. e4 e5 &lt;span&gt;2&lt;/span&gt;. Nf3 Nc6 &lt;span&gt;3&lt;/span&gt;. &lt;span&gt;Bb5 &lt;/span&gt;a6 &lt;span&gt;4&lt;/span&gt;. &lt;span&gt;Ba4 &lt;/span&gt;Nf6 &lt;span&gt;5&lt;/span&gt;. O-O &lt;span&gt;Be7 &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;. Re1 &lt;span&gt;b5 &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;. &lt;span&gt;Bb3 &lt;/span&gt;&lt;span&gt;d6&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;. &lt;span&gt;c3&lt;/span&gt; O-O &lt;span&gt;9&lt;/span&gt;. h3 Nb8 &lt;span&gt;10&lt;/span&gt;. &lt;span&gt;d4&lt;/span&gt; Nbd7 &lt;span&gt;11&lt;/span&gt;. &lt;span&gt;c4&lt;/span&gt; &lt;span&gt;c6&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;. cxb5 axb5 &lt;span&gt;13&lt;/span&gt;. Nc3 &lt;span&gt;Bb7 &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;. &lt;span&gt;Bg5 &lt;/span&gt;&lt;span&gt;b4 &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;. &lt;span&gt;Nb1&lt;/span&gt; h6 &lt;span&gt;16&lt;/span&gt;. &lt;span&gt;Bh4 &lt;/span&gt;&lt;span&gt;c5&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;. dxe5 Nxe4 &lt;span&gt;18&lt;/span&gt;. &lt;span&gt;Bxe7 &lt;/span&gt;Qxe7 &lt;span&gt;19&lt;/span&gt;. exd6 Qf6 &lt;span&gt;20&lt;/span&gt;. Nbd2 Nxd6 &lt;span&gt;21&lt;/span&gt;. &lt;span&gt;Nc4&lt;/span&gt; Nxc4 &lt;span&gt;22&lt;/span&gt;. &lt;span&gt;Bxc4 &lt;/span&gt;Nb6 &lt;span&gt;23&lt;/span&gt;. Ne5 Rae8 &lt;span&gt;24&lt;/span&gt;. &lt;span&gt;Bxf7+ &lt;/span&gt;Rxf7 &lt;span&gt;25&lt;/span&gt;. Nxf7 Rxe1+ &lt;span&gt;26&lt;/span&gt;. Qxe1 Kxf7 &lt;span&gt;27&lt;/span&gt;. Qe3 Qg5 &lt;span&gt;28&lt;/span&gt;. Qxg5 hxg5 &lt;span&gt;29&lt;/span&gt;. &lt;span&gt;b3 &lt;/span&gt;Ke6 &lt;span&gt;30&lt;/span&gt;. &lt;span&gt;a3&lt;/span&gt; Kd6 &lt;span&gt;31&lt;/span&gt;. axb4 cxb4 &lt;span&gt;32&lt;/span&gt;. Ra5 Nd5 &lt;span&gt;33&lt;/span&gt;. &lt;span&gt;f3&lt;/span&gt; &lt;span&gt;Bc8 &lt;/span&gt;&lt;span&gt;34&lt;/span&gt;. Kf2 &lt;span&gt;Bf5 &lt;/span&gt;&lt;span&gt;35&lt;/span&gt;. Ra7 g6 &lt;span&gt;36&lt;/span&gt;. Ra6+ Kc5 &lt;span&gt;37&lt;/span&gt;. Ke1 Nf4 &lt;span&gt;38&lt;/span&gt;. g3 Nxh3 &lt;span&gt;39&lt;/span&gt;. Kd2 Kb5 &lt;span&gt;1&lt;/span&gt;. Rd6 Kc5 &lt;span&gt;41&lt;/span&gt;. Ra6 Nf2 &lt;span&gt;42&lt;/span&gt;. g4 &lt;span&gt;Bd3 &lt;/span&gt;&lt;span&gt;43&lt;/span&gt;. Re6 &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이러한 표기 방식을 PGN(portable game notation)이라 부른다. 이런 식의 기록은 그 역사가 꽤 오래되었고 각 나라에 따라 입력 방법에 차이가 있었다. 지금으로부터 약 10년 전에 인터넷 뉴스그룹 rec.games.chess에서 Steven J. Edwards에 의해 정리되어 지금에 이르고 있다고 한다.&lt;/p&gt;
&lt;p&gt;이렇게 하나의 대국 내용을 모두 텍스트 문자의 형태로 기록하기 때문에 다른 사람에게 간편하게 전달할 수 있고, 특별한 뷰어도 필요하지 않고, 저장 용량도 크지 않다. 그리고 기록 방식이 표준화되어 있기 때문에 이 포맷을 지원하는 어떤 체스 프로그램에서도 그대로 사용할 수 있다. 재미있는 것은, 직접 같이 두기에는 너무 먼 거리에 있는 사람과도 다음 수를 위 표기 방법에 맞춰 적어 보냄으로써 체스를 둘 수 있다는 것이다. 실제로 PGN 포맷이 없었던 시절에도 다음 수를 우편으로 주고받으면서 체스를 두기도 했다.&lt;/p&gt;
&lt;p&gt;우리네 바둑이나 장기도 이런 식으로 표시하면 활성화의 한 방향이 되지 않을까. 지금의 대국 기보는 전용 프로그램이 있어야 볼 수 있고, 프로그램 간 호환이 보장되지 않는다는 점에서 많은 장애가 되고 있다.&lt;/p&gt;
&lt;p&gt;PGN 표기에 관한 표준 문서는 다음 URL에서 웹으로 볼 수 있다:&lt;br /&gt;&lt;a href=&quot;http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm&quot;&gt;http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm&lt;/a&gt;&lt;/p&gt;</description>
<category>기술</category>
<category>Chess</category>
<category>pgn</category>
<author>devage</author>
<guid>https://devage.tistory.com/24</guid>
<comments>https://devage.tistory.com/24#entry24comment</comments>
<pubDate>Wed, 21 Aug 2019 00:41:46 +0900</pubDate>
</item>
<item>
<title>IP 프로토콜 이야기</title>
<link>https://devage.tistory.com/23</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;2004.07.06에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;오랫동안 제2계층과 제4계층은 처음부터 여러 종류의 표준들이 사용되어 왔고, 앞으로도 새로운 기술들이 속속 등장할 것이다. 제2계층에는 802.3, ATM, 802.11 series 등이 유명하고, 제 4계층에는 대표적인 UDP, TCP 외에도 최근 표준화가 완료된 SCTP 등을 예로 들 수 있다.&lt;/p&gt;
&lt;p&gt;이렇게 인터넷이라는 한울타리 내에서 다양한 기술들이 사이좋게 양립될 수 있었던 까닭은 이 다양성을 제 3계층의 IP (Internet Protocol) 프로토콜이라고 하는 하나의 공통점이 묶어주고 있기 때문이다. &amp;nbsp;IP 프로토콜은 내가 찾는 상대방이 인터넷 상의 어디에 있든 -- 바로 옆이거나 지구 반대편이거나에 상관없이 -- 패킷을 전송할 수 있도록 한다. 즉 인터넷을 'IP 프로토콜에 의해 패킷이 전송되는 네트워크'로 정의할 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 인터넷에 연결된 모든 네트워크들이 같은 IP 프로토콜을 사용하도록 하는 것은 무척 중요한 일이다. 만약 IP가 아닌 전혀 다른 프로토콜을 사용하는 사용자가 생겨난다면 그 사람은 IP를 사용하는 사람과의 통신이 불가능한 것은 물론이고, 때에 따라서는 다른 사람의 통신까지 막을 수도 있다.&lt;/p&gt;
&lt;p&gt;그러나 앞으로는 현재의 IP 프로토콜을 계속 고집하기가 어려워지고 있는데, 이유는 각 컴퓨터에게 할당해줄 주소가 거의 없어졌기 때문이다. 초기의 IP 프로토콜 설계자에게 있어서 인터넷은 국제적인 학문 연구 및 군사용 등의 특수용도 망이었고 따라서 지금처럼 수많은 일반인들까지 쓸 줄은 미처 몰랐던 것이다. 게다가 앞으로는 한 사람에게 한 개 씩은 커녕 한 사람에게 여러 개의 주소를 할당해주어야 하게 생겼다. 지금도 핸드폰과 노트북과 PDA를 다 가지고 다니는 사람들이 많지 않은가. 따라서 현재의 IP 프로토콜을 개정할 필요가 있었다.&lt;/p&gt;
&lt;p&gt;이리하여 10년 전부터 표준화가 진행되었던 차세대 IP 프로토콜 (IPng, IP next generation)은 IPv6 (IP version 6)라는 결과물로 구체화되었다. 참고로 현재 사용하고 있는 IP 프로토콜의 버전은 4이며(그래서 IPv4라고 부른다), IPv5는 모바일 용도로 따로 예약이 되어있다.&lt;/p&gt;
&lt;p&gt;그럼 무엇이 바뀌었는가. 제일 큰 차이점은 주소의 길이이다. 적을 수 있는 주소의 길이가 늘어남으로써 그만큼 더 많은 사용자를 포용할 수 있게 된 것이다. 잘 이해가 가지 않는다면, 전화번호를 생각하면 되겠다. 지역번호를 제외한 나머지 자리를 갖고 보자면, 국번 포함 7자리 보다 8자리가 더 많은 가입자를 받을 수 있을 것이다. 마찬가지로, 인터넷 주소의 자리수는 비트 수를 기준으로 계산한다. IPv4에서는 주소 길이가 32비트였으나 IPv6 주소의 길이는 128비트로, 실제로 2^(128-32) 수 만큼의 가입자를 더 받을 수 있는 양이다. 지금 한 번 계산기를 한 번 두들겨 보시라. 최소 억 단위 값이 나올 것이다.이제 제일 큰 문제를 해결했으니, 그것으로 끝내도 좋았다. 그런데 기왕지사 바꿀 거 지금까지 잡음이 많았던 골칫거리들도 송두리째 뽑자고, 여기저기 뚝딱뚝딱 수선했다.&lt;/p&gt;
&lt;p&gt;첫번째는 보안 기능을 넣을 수 있는 공간의 확보이다. 흔히들 'IPv6는 보안 기능이 우수하다'고 말하는데, 엄밀히 말하자면 거짓말이다. IPv6 자체로는 아무런 보안 기능이 없다. 지금까지는 제 3계층 수준에서의 보안을 위해서는 별도의 추가 프로토콜을 위한 수정을 필요로 했고, 일단 기본 프로토콜 스펙에 &amp;nbsp;없는 내용이다 보니 '옵션'이란 인식이 강했다. IPv6에서는 기본 표준 문서에 인증 내용 및 데이터 암호화 내용이 들어가야 할 자리를 명시해줬고(AH 및 ESP 확장 헤더), 보안을 위한 기능이 '반드시' 들어가야 한다고 명시하였다. 이로서 IPv6가 탑재되는 모든 장비 -- 컴퓨터건, 휴대폰이건 -- 에는 인증 및 암호화 기능이 반드시 탑재되고, 마치 '숨쉬듯이' 필요할 때면 언제든지 보안 기능을 사용할 수 있게 되는 것이다.&lt;/p&gt;
&lt;p&gt;두번째는 확장 기능의 유연한 추가 능력이다. IPv4에서도 확장 기능은 'IP 헤더 옵션'이라는 이름으로 사용되어 왔지만 이 옵션을 지원하지 않는 라우터에서는 어떻게 처리하도록 해야 하는 지에 대한 규정이 없었다. 새로운 옵션을 추가하려 할 때마다 이 옵션을 지원하지 않는 컴퓨터 또는 라우터에서 어떻게 처리될 지까지 고민하고 추가하는 것은 상당히 골칫거리다. 새로운 IP 프로토콜에서는 새로 추가할 옵션 내용의 포맷을 통일하고, 패킷으로부터 알 수 없는 옵션을 찾아낸 경우 이에 대한 처리 방식까지 명시하도록 되어있다.&lt;/p&gt;
&lt;p&gt;세번째는 두번째와도 관련 있는 내용인데, 헤더 구성을 아주 심플하게 만들었다는 점이다. 불필요하거나 잘 사용되지 않는 영역을 옵션 기능으로 빼고, 기본 필드 갯수를 IPv4 때보다 더 줄였다. 이렇게 하면 무엇이 좋아지는가? 대부분의 라우터는 패킷을 하드웨어적으로 처리한다. 즉 기판 위의 회로를 통과하는 동안에 다음 처리 방법이 결정되는데, 이는 메모리에 올린 다음에 작업을 수행하는 소프트웨어적인 처리보다 훨씬 빠르다. 대신 구현하기가 힘들다는 단점이 있는데, 패킷 형식이 간략해지면 하드웨어적으로 구현하기가 쉬워진다.&lt;/p&gt;
&lt;p&gt;IPv6는 현재의 IPv4와 동격의 프로토콜이면서 IPv4 운용 경험에 기반하여 많은 수정이 이루어진 프로토콜이다. 그러면 왜 이렇게 좋은 것을 안쓰는가? 일단 인터넷 기술 주도국인 미국은 이미 많은 주소 공간을 선점하고 있기 때문에 그다지 바꾸어야 할 필요성을 못느끼고 있다. 즉 장래의 필요 때문에 표준을 만들기는 했는데 사용에는 별 관심이 없다는 것이다. 이런 상황에서 하루라도 빨리 IPv6로 전환하기 위해서는 어떤 계기가 필요한데 그 중의 하나가 WWW와 같은 킬러 어플리케이션이다. 그러나 IPv6 표준화의 주요 이슈가 주소 부족 문제의 해결이었기 때문에 동기 유발을 위한 조건으로는 미흡하다. 현재로는 All-IP 망과 같은 차세대 신규 네트워크에서의 도입을 우선 시하여 주도되고 있다.&lt;/p&gt;</description>
<category>기술</category>
<category>IPv6</category>
<author>devage</author>
<guid>https://devage.tistory.com/23</guid>
<comments>https://devage.tistory.com/23#entry23comment</comments>
<pubDate>Wed, 21 Aug 2019 00:40:05 +0900</pubDate>
</item>
<item>
<title>위대한 보스가 팀과 사일로의 차이에 대해 알고 있는 것</title>
<link>https://devage.tistory.com/21</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2011.06.09에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Jill Geisler, 2010년 3월 12일 오후 3:59&lt;/p&gt;
&lt;p&gt;관리자들은 종종 부하직원들에게 팀 빌더가 될 것을 요구한다. 그들은 단순한 개개인의 집합에서 직장에서 서로를 도와주고 직장 밖에서도 서로 친구가 되기도 해주는 그런 효율적인 팀으로 변신하길 기대한다.&lt;/p&gt;
&lt;p&gt;좋은 얘기다. 전체는 그 부분의 합보다 크다. 팀원들은 자원과 아이디어, 그리고 공통 목표를 공유한다. 사람들은 그들이 갖고 있는 능력과 (&quot;우리는 기술자에요&quot;라든가 &quot;우린 디자인 전문가입니다&quot; 등) 조직 내에서 인지하는 위치 &amp;ndash; 패배자에서부터 수퍼 스타에 이르기까지 &amp;ndash; 에 따라 팀원들 사이에 공유하는 정체성을 만들어간다.&lt;/p&gt;
&lt;p&gt;리더들의 도움으로 그들은 공통의 적을 만들기도 하는데 보통 외부의 경쟁자가 이에 해당한다. 팀은 마지막에 기립박수를 보내게 되는 영화에서처럼 상대편을 무찌르기 위해 뭉치게 된다.&lt;/p&gt;
&lt;p&gt;하지만 잠깐 박수를 접어두자. 팀은 확인해볼 필요가 있는 잠재적인 나쁜 측면을 가지고 있다.&lt;br /&gt;이 모든 것은 팀을 사일로로 만들기 위한 몇 가지의 변화이다 &amp;ndash; 사일로는 고립된 팀으로서는 일을 잘 하지만 다른 팀과 같이 일하는 것은 잘 하지 못한다. 사일로는 그들 자신만의 일정을 관리한다. 사일로는 변화를 주저하고, 혁신을 방해하며 불필요한 지출을 만든다.&lt;/p&gt;
&lt;p&gt;여기에 그 차이를 쉽게 볼 수 있는 표가 있다.&lt;/p&gt;
&lt;p&gt;팀과 사일로의 특성&lt;/p&gt;
&lt;table style=&quot;border-collapse: collapse; width: 56.1839%; height: 133px;&quot; border=&quot;1&quot; data-ke-style=&quot;style2&quot;&gt;
&lt;tbody&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;height: 19px; text-align: center;&quot;&gt;팀&lt;/td&gt;
&lt;td style=&quot;height: 19px; text-align: center;&quot;&gt;사일로&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;공통의 정체성&lt;/td&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;공통의 정체성&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;정보를 공유함&lt;/td&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;정보를 보호함&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;조직의 큰 그림을 봄&lt;/td&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;그들만의 목표에 대한 그림을 봄&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;그룹 간의 네트워크를 형성&lt;/td&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;외부와의 접촉을 피함&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;&quot;우리와 너&quot;&lt;/td&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;&quot;우리 대 너&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style=&quot;height: 19px;&quot;&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;보스 스타일: 협력&lt;/td&gt;
&lt;td style=&quot;width: 413px; height: 19px; text-align: center;&quot;&gt;보스 스타일: 제어&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;리더는 팀의 지평을 확장하고, 팀의 멤버들을 보다 큰 비전에 연결한다. 여기서 리더십은 핵심적인 요소이다. 그렇다. 멤버들은 이도저도 아닌 패배자가 될 수도 있고 창조적인 아티스트가 될 수도 있다. 그러나 그들은 항상 보다 큰 노력의 일부이다. 리더들은 팀이 사일로가 되지 않도록 다음과 같은 일을 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀 멤버들에게 명확한 역할과 목표를 정의한다&lt;/li&gt;
&lt;li&gt;멤버들에게 그들이나 팀 뿐만 아니라 모든 직장 동료들을 위해 문제 해결을 위한 마인드를 갖도록 유도한다&lt;/li&gt;
&lt;li&gt;조직의 주요 전략과 선도 요소에 관한 정보를 공유한다&lt;/li&gt;
&lt;li&gt;우선순위에 관해 명확한 지시를 내린다&lt;/li&gt;
&lt;li&gt;제 일선에서 중요한 의사 결정을 내린다&lt;/li&gt;
&lt;li&gt;조직 내에서 팀의 협력적인 접근 방식을 인정받고 보상 받을 수 있도록 위, 아래, 옆쪽 등 조직의 모든 방향으로 소통한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여러분이 사일로를 관리하는 것이 아니라 협력적인 팀을 이끄는 것이길 빈다. 이 꽃밭을 지키기 위해 변화를 시도하려 할 때 그 방법은 어떤 것이 있는가? (What if you're trying to help a turf-protective bunch change its ways?)&lt;br /&gt;3분짜리 팟캐스트를 통해 몇 가지 팁을 제공한다.&lt;/p&gt;
&lt;blockquote&gt;@estima7Jungwook Lim&lt;br /&gt;팀과 사일로에 대한 좋은 글.&lt;a href=&quot;http://bit.ly/iqigaZ&quot;&gt;http://bit.ly/iqigaZ&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;3분짜리 팟캐스트도 들어볼만. 내가 지금까지 조직에서 실제로 겪은 많은 사일로가 이랬음. 사일로를 만드는 것은 결국 그 조직의 리더.&lt;/blockquote&gt;</description>
<category>번역</category>
<category>leadership</category>
<category>Silo</category>
<category>TEAM</category>
<author>devage</author>
<guid>https://devage.tistory.com/21</guid>
<comments>https://devage.tistory.com/21#entry21comment</comments>
<pubDate>Tue, 20 Aug 2019 18:16:50 +0900</pubDate>
</item>
<item>
<title>반년 만에 이용자 300만명! 초인기 사진 앱 'Instagram', CEO가 말하는 성공 요인</title>
<link>https://devage.tistory.com/20</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2011.06.07에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(닛케이 트렌디 특집 &amp;lsquo;facebook&amp;amp;twitter&amp;rsquo; 연동기획, 미국 소셜미디어 핵심인물 인터뷰)&lt;/p&gt;
&lt;p&gt;트위터로 사진을 공유할 수 있는 앱으로, 일본에서도 높은 인기를 얻고 있는 아이폰 앱 &amp;lsquo;Instagram (인스타그램)&amp;rsquo;. 20대 청년 두 명이 개발한 이 무료 앱은 공개 후 약 반년 만에 300만명 이상의 유저를 모아, 순식간에 아이폰의 사진 앱을 대표하는 존재가 됐다.인스타그램은 어째서 이 정도까지 성공했을까. 이제부터는 어떻게 발전해나갈 것인가. 미국 샌프란시스코의 본사에서 CEO 케빈 시스트롬으로부터 이야기를 들었다.&lt;/p&gt;
&lt;blockquote&gt;Instagram (Burbn, Inc.)&lt;br /&gt;CEO 케빈 시스트롬&lt;br /&gt;Kevin Systrom 스탠포드 대학 졸업. 구글 근무를 거쳐 인스타그램을 설립했다. 창업 시 멤버는 2명. 현재도 겨우 네 명. 트위터의 창업자 두 명이 설립한 Odeo라는 회사에서 인턴으로 근무한 경험이 있다. 샌프란시스코에 있는 인스타그램 본사는 트위터 창업 시 입주해 있던 건물.&lt;/blockquote&gt;
&lt;blockquote&gt;Instagram (무료)&lt;br /&gt;아이폰으로 촬영한 사진에 &amp;lsquo;필터&amp;rsquo;라 부르는 가공을 한 후 트위터나 페이스북에 투고할 수 있는 앱. 무료 앱이면서도 15종류 이상의 필터를 사용할 수 있으며, 간단한 조작으로 사진의 분위기를 크게 바꿀 수 있어 큰 인기를 모으고 있다. 트위터나 페이스북과의 연계도 뛰어나지만, 인스타그램 자체에도 SNS으로서의 기능을 갖고 있다. 자발적 참여에 의해 인터페이스는 일본어화 되어 있다.&lt;/blockquote&gt;
&lt;h2 id=&quot;-1-5-&quot;&gt;세계에서 1초마다 5매의 사진이 업로드되고 있어&lt;/h2&gt;
&lt;p&gt;[사진] 샌프란시스코 시내에 있는 본사. 한때 트위터가 입주해 있던 건물&lt;/p&gt;
&lt;p&gt;&lt;b&gt;---인스타그램 공개 후 대히트 까지의 경위에 대해 알려주기 바란다. 큰 인기를 끄는 앱이 된 계기가 뭔가 있었는가.&lt;/b&gt;&lt;br /&gt;&lt;b&gt;케빈 시스트롬(이하 시스트롬):&lt;/b&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;없었다고 생각한다. 인스타그램을 앱스토어에 공개했던 것은 작년 10월. 첫날부터 엄청난 수의 유저들이 모여서 우리들도 놀랐다. 지금은 사용자 수가 300만명을 넘어섰으며, 월 수십만 명 이상의 페이스로 계속 증가하고 있다. 사진 투고 수는 전세계에서 초당 5장, 시간당 약 1만8천 장이다 (4월 중순 시점).&lt;br /&gt;트위터에 사진을 공유하는 서비스는 이전에도 있었지만, 당시에는 &amp;lsquo;yFrog&amp;rsquo; 등의 유명한 것의 다수가 PC에서의 사용을 전제로 한 서비스였다. 모바일을 고려한 서비스는 적었고, 사람들이 모처럼 스마트폰을 통해서 트위터를 사용하고 있는데, 사진 공유에는 실시간성이 부족했다. 인스타그램은 그 구멍을 메울 뿐 아니라 상상력을 자극하는 필터 기능을 넣은 것이 성공 요인이었다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;---인스타그램은 일본에서 인기가 상당히 높다. 왜인가.&lt;/b&gt;&lt;br /&gt;&lt;b&gt;시스트롬:&lt;/b&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;정확히 확인한 것은 아니지만, 전체 사용자의 50%를 미국인 사용자가, 그리고 25%를 일본인 사용자가 점유하고 있다. 일본은 미국에 이어 2위의 사용자 수를 갖고 있다. 트위터가 계속 보급되고 있어서 인기를 이어가고 있다. 또한, 인스타그램에는 영어를 몰라도 사용할 수 있어서 비영어권 국가의 사람과도 사진으로 통할 수 있다는 장점도 있다.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;안드로이드 버전도 개발한다&lt;/h2&gt;
&lt;p&gt;[사진] 현재 개발멤버는 4명. 아마존 서버를 이용하고 있다고&lt;/p&gt;
&lt;p&gt;&lt;b&gt;---향후 발전 방향에 대해서는.&lt;/b&gt;&lt;br /&gt;&lt;b&gt;시스트롬:&lt;/b&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;최근에는 사진에 코멘트를 달 수 있도록 했으며, 필터 수도 늘려가고 있다. 향후 기능확장에 관한 아이디어도 여러가지가 있다. 사진에 낙서하는 기능이라든가, 페이스북에서도 하고 있는 것처럼 사진에 있는 사람의 이름을 태그로 달 수 있는 기능이라든가. 또한 짧은 동영상을 인스타그램에 투고할 수있는 기능과 같이 좀더 재미있는 것도 생각하고 있다. 다만 일본과 달리 미국에서는 모바일 회선의 속도가 충분하지 않다는 문제가 있어서 고민하고 있는 중이다.&lt;br /&gt;안드로이드 버전의 앱이 없기 때문에 많은 사용자가 &amp;lsquo;picplz&amp;rsquo; 등의 경쟁 앱으로 흘러가고 있다는 것을 알고 있다. 이를 위해 아이폰용 앱의 서비스 안정화에 주력해왔지만 앞으로는 안드로이드용 앱도 개발할 생각이다.&lt;br /&gt;수익을 창출하기 위해서 광고 모델 등을 생각하고 있지만, 지금은 아무래도 더 많은 사용자들이 인스타그램을 사용토록 하는 것을 생각하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;---인스타그램의 목표를 알려달라.&lt;/b&gt;&lt;br /&gt;&lt;b&gt;시스트롬:&lt;/b&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;목표는 트위터나 페이스북과 나란히 설 수 있는 커다란 소셜미디어 업체로 성장하는 것. 지금의 성장속도로 볼 때 불가능한 것은 아니라고 생각한다.&lt;/p&gt;
&lt;p&gt;(글 / 有我武紘 = 닛케이트렌디・취재협력 / 飯塚真紀子 사진 / Seng Chen)&lt;/p&gt;
&lt;blockquote&gt;@5wlim Sangwook Lim&lt;br /&gt;뒤늦게 발견한 닛케이의 Instagram CEO인터뷰&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://goo.gl/XAfO2(일본어)&quot;&gt;http://goo.gl/XAfO2(일본어)&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;흥미로운 포인트:1.감각적으로 업로드셰어는 미국 50%, 일본 25%정도 2.미국데이터통신 속도가 느려 고민중 3.안드로이드앱도 곧 개발착수하고 싶다.&lt;/blockquote&gt;
&lt;p&gt;source:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://trendy.nikkeibp.co.jp/article/column/20110513/1035642/?P=1&quot;&gt;http://trendy.nikkeibp.co.jp/article/column/20110513/1035642/?P=1&lt;/a&gt;&lt;/p&gt;</description>
<category>번역</category>
<category>instragram</category>
<author>devage</author>
<guid>https://devage.tistory.com/20</guid>
<comments>https://devage.tistory.com/20#entry20comment</comments>
<pubDate>Tue, 20 Aug 2019 18:13:25 +0900</pubDate>
</item>
<item>
<title>트위터에서 사진 공유 서비스를 개시할 예정</title>
<link>https://devage.tistory.com/19</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2011.05.31에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Emily Banks | 2011년 5월 31일&lt;/p&gt;
&lt;p&gt;월요일 오후 루머 관련 사이트에서는 트위터 사에서 자체적으로 사진 공유 서비스를 준비하고 있으며 Twitpic이나 Yfrog 등과 경쟁할 것 같다는 리포트에 들썩이고 있다.&lt;/p&gt;
&lt;p&gt;TechCrunch가 월요일 오후에 제일 먼저 다수의 익명 정보원들의 이야기를 언급했다. 그리고 이제 All Things D에서 이에 대해 확인해주면서, 언급된 서비스는 이번 주에 발표될 것이라고 덧붙였다. ATD의 이야기 또한 익명의 정보원에 의해 언급된 것이지만, 이번 주 캘리포니아의 Rancho Palos Verdes에서 열리는 ATD D9 컨퍼런스에서 발표될 것이라고 확인해주었다.&lt;/p&gt;
&lt;p&gt;이번 소식은 사실로 드러나더라도 엄청난 놀라움을 주지는 않을 것이다. Twitter 사에서는 개발자들에게 써드파티 클라이언트 개발을 중지해줄 것을 요청한 이후, TweetDeck 인수를 발표했다. 그러나 위의 루머들이 최종적으로 확인되기까지 수 개월이 걸렸다. 따라서 Twitter에서 사진 공유 서비스에 관해 어떻게든 공식 발표를 하기 전까지 한동안은 관련 루머들을 계속 듣게 될 것이다.&lt;/p&gt;
&lt;p&gt;우리는 Twitter에 이에 대한 의견을 요청하고 있으며 새로운 정보를 얻게 되면 본 포스트에 업데이트 할 것이다.&lt;br /&gt;&lt;b&gt;업데이트: Twitter 대변인은 본 리포트에 대해 코멘트할 것이 없다고 응답했다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;source:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://on.mash.to/kcNnaa&quot;&gt;http://on.mash.to/kcNnaa&lt;/a&gt;&lt;/p&gt;</description>
<category>번역</category>
<category>twitter</category>
<author>devage</author>
<guid>https://devage.tistory.com/19</guid>
<comments>https://devage.tistory.com/19#entry19comment</comments>
<pubDate>Tue, 20 Aug 2019 18:11:57 +0900</pubDate>
</item>
<item>
<title>꼼꼼히 살펴보고, 단칼에 처리하기</title>
<link>https://devage.tistory.com/18</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2011.05.23에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;iOS 개발자에게 특허 침해 경고를 하고 있는 Lodsys에 대한 애플의 오늘 대응은 다음과 같이 되풀이되는 패턴을 보여주는 또 하나의 예이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;애플과 연관된 위험이나 문제가 발생한다.&lt;/li&gt;
&lt;li&gt;즉시 뉴스 거리나 추측의 대상이 된다.&lt;/li&gt;
&lt;li&gt;일주일 이상 지난 후 애플이 이에 대해 대응한다. 그런데 그 대응은 매우 신속하고 효율적이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;아이폰4 데스그립 문제에도 그랬고 iOS 위치 로깅 데이터베이스 문제 때도 마찬가지였으며 이번 경우도 같은 패턴으로 진행되었다. 애플의 대응은 Lodsys가 iOS 개발자들에게 특허 침해에 대한 경고를 시작한 지 열흘 정도 밖에 지나지 않았으며 이마저도 주말 이틀을 포함한 것이다. Lodsys로부터 침해 경고를 받았던 몇몇 친구들과 대화를 통해 길고 긴 열흘이었으며 아직도 그렇게 느낀다는 것을 알고 있다. 소송은 심각히 고려해야 할 문제이고, 앱스토어는 애플에게 왕관의 보석만큼이나 소중한 것이다. 맞건 틀리건 간에, 애플의 입장은 문제에 대해 제대로 준비가 안된 상태에서 바로 응답함으로써 문제를 키우기보다 대응에 최대한 시간을 들이는 것이다.&lt;/p&gt;
&lt;p&gt;애플의 정책은 문제에 대해 확실한 대응책을 내놓는 것이고, 그렇지 못하더라도 적어도 최대한의 확실성을 확보하는 것이다. 확실한 대응책을 내놓으려면 시간이 필요하다. 찔끔찔끔 무지한 홍보용 성명서를 내보내지 않는다. 단지 조용히 있다가 응답할 뿐이다. 보기에 그들은 잘 대응하고 있는 것 같다.&lt;/p&gt;</description>
<category>번역</category>
<category>Apple</category>
<category>patent</category>
<author>devage</author>
<guid>https://devage.tistory.com/18</guid>
<comments>https://devage.tistory.com/18#entry18comment</comments>
<pubDate>Tue, 20 Aug 2019 18:10:51 +0900</pubDate>
</item>
<item>
<title>BlueStacks 안드로이드 앱을 x86 기반 윈도우즈 디바이스에서 사용할 수 있도록 개발 중</title>
<link>https://devage.tistory.com/17</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2011.05.27에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;By Rachel King | May 25, 2011, 12:25pm PDT&lt;/p&gt;
&lt;p&gt;&lt;b&gt;BlueStacks&lt;/b&gt;는 안드로이드 OS 앱을 윈도우즈 기반 디바이스에서 지속적으로 지원하기 위한 개발을 진행 중이다. 새로 보증을 받은 벤처 캐피털에 따르면 개발 여전히 진행 중이라고 한다. 실리콘 밸리에 있는 이 회사는 일단의 투자자들로부터 단독 개발 명목으로 760만 달러의 Series A 파이낸싱을 받았다.&lt;/p&gt;
&lt;p&gt;기본적으로 BlueStacks의 아이디어는 기업 및 소비자 정도의 컴퓨터 사용자들이 같은 장비에서 안드로이드 및 윈도우즈 응용 프로그램을 같이 실행할 수 있도록 하여 별도의 장비를 구매하여 보유하지 않아도 되도록 하는 것이다. BlueStacks 대변인은 또한 윈도즈 상에서 안드로이드 앱을 실행하고 동작할 때 시간 지연이 없을 것이라고 약속했다. 따라서 윈도즈에서 안드로이드 앱을 거의 끊김 없이 사용할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;이는 또한 안드로이드 및 윈도우즈 앱 양쪽의 개발자들에게 이익이 된다. 소비자들이 단일 OS에 제약을 받지 않는다면 (특히 여러 개의 OS 때문에 여러 대의 기계를 사지 않아도 되므로), (응용 프로그램의) 수요 시장은 꽤 커질 수 있다. 개발자들은 이미 다른 운영체제에서 실행되는 응용 프로그램을 다른 운영체제에 맞게 최적화할 필요가 없으므로 시간을 절약할 수 있다.&lt;/p&gt;
&lt;p&gt;지금까지 BlueStacks는 안드로이드 앱을 x86 기반의 타블렛, 넷북, 노트북 및 올인원 컴퓨터에서 사용할 수 있도록 작업 중이다. 소프트웨어는 6월이나 7월에 베타 버전이 나올 수 있을 것이다. OEM 제조사들은 자신의 제품에 미리 이 기술을 탑재할 수 있을 것이며, 따라서 소비자나 회사의 IT 부서에서는 추가 비용이 들지 않을 것이다.&lt;/p&gt;
&lt;p&gt;이에 더해, Citrix CEO인 Mark Templeton은 수요일 샌프란시스코에서 열린 Citrix Synergy 에서 Citrix Receiver와 함께 BlueStacks의 소프트웨어가 플러그인 형태로 동작하고 &amp;ldquo;안드로이드 앱을 어느 디바이스에서나 실행할 수 있을 것이며,&lt;span&gt;&amp;nbsp;&lt;/span&gt;IT에서 소비자화를 받아들이고&lt;span&gt;&amp;nbsp;&lt;/span&gt;직원들의 생산성을 향상시킬 수 있을 것이다&amp;rdquo;라고 발표했다.&lt;/p&gt;
&lt;hr style=&quot;box-sizing: border-box; height: 1px; display: block; margin: 0px 0px 2em; padding: 0px; background: #e5e4e1; border: 0px; min-width: 100%; max-width: 100%; color: #45484d; font-family: 'Noto Sans KR', sans-serif; font-size: 20px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 300; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;&quot; /&gt;
&lt;p&gt;다음 트윗의 글을 공부 차 번역했습니다 :)&lt;/p&gt;
&lt;blockquote&gt;블루스택이 x86 윈도 운영체제에 안드로이드 앱을 올릴 수 있는 SW 개발 중. 격세지감이죠? 윈도 호환 만들기에 열중하던 것이 엊그제 같은데 -&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://goo.gl/dMxAt&quot;&gt;http://goo.gl/dMxAt&lt;/a&gt;&lt;br /&gt;by hiconcep at 11. 5. 26. 8:45&lt;/blockquote&gt;
&lt;p&gt;(Source:&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://twitter.com/hiconcep/status/73535306057515008&quot;&gt;http://twitter.com/hiconcep/status/73535306057515008&lt;/a&gt;)&lt;/p&gt;</description>
<category>번역</category>
<category>Android</category>
<category>bluestacks</category>
<author>devage</author>
<guid>https://devage.tistory.com/17</guid>
<comments>https://devage.tistory.com/17#entry17comment</comments>
<pubDate>Tue, 20 Aug 2019 18:09:19 +0900</pubDate>
</item>
<item>
<title>일본 livedoor 무선랜 서비스 이용기</title>
<link>https://devage.tistory.com/15</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2005.09.19에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/b7YYUp/btqxAdapen9/5dEw9dkjv23goH2mRtH5Ck/img.jpg' data-lightbox='lightbox' data-alt='Livedoor WiFi AP'&gt;&lt;img src='https://k.kakaocdn.net/dn/b7YYUp/btqxAdapen9/5dEw9dkjv23goH2mRtH5Ck/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fb7YYUp%2FbtqxAdapen9%2F5dEw9dkjv23goH2mRtH5Ck%2Fimg.jpg' data-filename=&quot;livedoor_1-1.jpg&quot;&gt;&lt;/span&gt;&lt;figcaption&gt;Livedoor WiFi AP&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;0-&quot;&gt;0) 소개&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.livedoor.co.jp/&quot;&gt;Livedoor&lt;/a&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;사는 일본의 웹 포탈 서비스 업체 중 하나입니다. 올해 초에 이 회사에서 'livedoor 무선랜 서비스'를 발표했는데, JR 야마노떼선 (우리나라의 지하철 2호선과 같은 순환선입니다) 내부 권역에 총 2,200 여개의 무선랜 접속용 억세스 포인트를 설치해서, 실내/실외 어디에서나 인터넷 접속 서비스를 제공합니다. 9월 현재 일부 지역에서 무료 시범 서비스를 이용할 수 있으며, 오는 11월부터 본격적인 유료 서비스를 제공합니다. 무선랜 기술은 IEEE 802.11b/g로 최대 54Mbps의 속도를 지원하며, 억세스 포인트에서부터는 광 케이블로 유선 인터넷에 연결됩니다. 이용 금액은 초기 가입금 1,050엔(약 만원)에 월 525엔(약 5천원) 정액제입니다.&lt;/p&gt;
&lt;h3 id=&quot;1-&quot;&gt;1) 가입&lt;/h3&gt;
&lt;p&gt;Livedoor 무선랜 서비스를 이용하기 위해서는, 총 세 번의 등록 절차가 필요합니다. 좀 귀찮은 편이지요. 첫번째로 livedoor 포털 서비스에 가입해야 합니다. 우리나라에서와 달리 주민등록번호 같은 것 없이 우편번호만 잘 입력하면 됩니다. 두번째는 livedoor wallet(ウォレット)이라고 부르는 livedoor ID 별 결재 정보 등록입니다. 이 정보는 livedoor 내의 유료 서비스를 결재하는데 사용됩니다. 마지막으로 livedoor 무선랜 서비스를 신청해야 하는데, 여기에 거주지 주소 및 연락 전화번호를 적는 난이 있습니다. 저는 초지일관 호텔 주소를 사용했습니다. --; 등록이 완료되면 로그인 ID와 SSID, WEP key, 그리고 설정 가이드를 위한 URL 정보가 메일로 전송됩니다.&lt;/p&gt;
&lt;h3 id=&quot;2-&quot;&gt;2) 접속&lt;/h3&gt;
&lt;p&gt;메일로 받은 SSID와 WEP key 정보를 갖고 livedoor 네트워크가 잡히는 곳에 가서 접속하면 됩니다. 먼저&lt;span&gt;&amp;nbsp;&lt;/span&gt;livedoor-web&lt;span&gt;&amp;nbsp;&lt;/span&gt;이라는 네트워크가 잡히면 WEP key를 입력하고 802.1X 인증 모드를 끕니다. 설정이 끝난 후에 웹 브라우저를 열면 자동으로 livedoor 웹 인증 페이지로 이동합니다. 여기에 자신의 livedoor ID와 password를 입력하면 다음부터 인터넷을 사용할 수 있게 됩니다. 가끔&lt;span&gt;&amp;nbsp;&lt;/span&gt;livedoor-dot1x라는 네트워크도 함께 검색되는 경우도 있는데, 웹 기반 인증 방식 대신 802.1X 인증 방식을 사용합니다. 현재는 사용할 수 없습니다.&lt;/p&gt;
&lt;h3 id=&quot;3-&quot;&gt;3) 사용 및 소감&lt;/h3&gt;
&lt;p&gt;자, 이제 livedoor 네트워크가 되는 곳만 찾으면 됩니다... 이지만 이게 쉬운 일이 아니었습니다! 상식적으로는 신쥬쿠 일대에서 번화가 주변이면 찾을 수 있다고 생각했는데, 실제로는 한산한 주택가에서 주로 잡히더군요. 등잔불 밑이 어둡다는 격으로, 제가 숙박하고 있는 호텔 근처에서 찾았습니다. __)&lt;br /&gt;나중에야 알았지만 번화가에는 의외로 억세스 포인트를 설치하기가 힘들답니다. 설치 공사 허가가 나와야 하는데 사람이 많이 몰리는 지역일수록 이것 저것 신경 써야 할 것이 많으므로 행정 처리에 시간이 오래 걸리지요.&lt;/p&gt;
&lt;p&gt;오전에 약 30분 간 테스트를 해봤습니다. 한쪽 억세스 포인트 앞에서 접속해서, 56kbps NHK 실시간 인터넷 라디오 방송에 접속했습니다. 하지만 실제 throughput은 32kbps. 처음에는 54Mbps 속도로 접속되었지만, 제가 노트북을 들고 반대쪽 livedoor 억세스 포인트까지 왕복했더니 1Mbps까지 대역폭이 감소했습니다. 즉, 보다 가까운 쪽에 억세스 포인트가 있어도 접속이 옮겨지지 않고 원래 억세스 포인트와의 연결을 계속 잡고 있다는 것인데, 따라서 이동하면서 네트워크를 계속 이용하는 것에는 부적합합니다.&lt;/p&gt;
&lt;p&gt;그리고 대부분의 억세스 포인트들이 전신주 등의 옥외 시설에 설치되기 때문에, 의외로 실내에서 사용하기에는 무리가 있습니다. 호텔을 중심으로 각각 70m, 80m 떨어진 곳에 억세스 포인트 장비들이 있는 환경이었음에도 불구하고 제 방에선 아예 잡히지도 않고, 일층 로비에서도 간신히 잡히거나 종종 없어집니다. 참고로 표준 상 통신 거리가 반경 250m, 실제로는 반경 약 150~200m입니다. 건물 외벽, 지나다니는 사람 및 차량 등에 의해 감쇄가 발생하며, 통신이 가능한 거리가 대폭 줄어들게 됩니다. 결국 '내 방 창문 앞에 있는 전신주에 억세스 포인트가 설치되어 있네'와 같은 이상적인 상황이 아니라면 모두 노트북을 들고 밖으로 나와서 사용해야 합니다. 이 정도면 livedoor가 아니라 outdoor이지요.&lt;/p&gt;
&lt;p&gt;이것저것 더 테스트해보고 싶었으나, 아침 출근 시간에 벽에 붙어서 노트북을 들고 작업하다가 갑자기 노트북을 귀에 대고 걸어다니다가 전신주에 바짝 붙어 위를 쳐다보는 모습 등등을 지나다니던 직장인과 학생들 그리고 동네 사람들이 모두 희한하게 쳐다보는 바 자칫하면 경찰까지 부를 것 같아 그만 포기하고 철수할 수 밖에 없었습니다. __)&lt;/p&gt;
&lt;h3 id=&quot;4-&quot;&gt;4) 마무리&lt;/h3&gt;
&lt;p&gt;우리나라에서 일본의 livedoor 무선랜 서비스와 비교될 수 있는 서비스는 네스팟 정도가 될 것 같습니다. livedoor는 일정 권역 내의 모든 곳에 억세스 포인트를 설치하고 인터넷 접속 서비스를 제공하는 방식인데 반해 네스팟은 학교, 커피숍, 회사 등 주요 hotspot이라고 예측되는 지점에 집중적으로 억세스 포인트를 설치하는 방식이지요.&lt;br /&gt;둘 다 장단점이 있습니다. 전자의 경우에는 주택 지구에서도 어디서든 인터넷 접속이 가능하다는 것이 장점이겠고, 후자의 경우에는 실내에서 편히 앉아서 접속할 수 있다는 점입니다. 아직까지 네트워킹의 활용 공간은 실외보다 실내가 더 높기 때문에 현재로서는 네스팟 방식에 손을 들어주고 싶습니다.&lt;/p&gt;
&lt;p&gt;반면 인증 방식은 livedoor의 손을 들어주겠습니다. Livedoor의 경우 현재 웹 페이지에서 인증을 처리하고 있고 향후 802.1X 기반의 인증 방식을 도입할 예정으로 있어 표준에 잘 부합하고 특정 운영체제에 독립적인 방식으로 운용하고 있습니다. 반면 네스팟은 윈도우 외에는 로그인 프로그램을 설치할 수 없지요.&lt;/p&gt;
&lt;p&gt;끝으로 전신주에 설치된 억세스 포인트의 실제 모습입니다. 일반 억세스 포인트보다 크기가 더 큰데, 방열 및 방한, 방수, 방진 등을 위한 케이스 때문으로 생각됩니다. 억세스 포인트를 구성하는 장비들과 케이블. 보기보다 구성은 단순합니다. 케이블들도 안테나선, 전원선, 데이터 케이블 등 알아보기 쉬운 것들로 구성.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/dCQcfr/btqxBQeROKF/z7jDMx7TGsH36DrZRhRJz0/img.jpg' data-lightbox='lightbox' data-alt='Livedoor WiFi AP'&gt;&lt;img src='https://k.kakaocdn.net/dn/dCQcfr/btqxBQeROKF/z7jDMx7TGsH36DrZRhRJz0/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdCQcfr%2FbtqxBQeROKF%2Fz7jDMx7TGsH36DrZRhRJz0%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Livedoor WiFi AP&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;</description>
<category>기술</category>
<category>livedoor</category>
<category>tokyo</category>
<category>WiFi</category>
<author>devage</author>
<guid>https://devage.tistory.com/15</guid>
<comments>https://devage.tistory.com/15#entry15comment</comments>
<pubDate>Tue, 20 Aug 2019 17:27:22 +0900</pubDate>
</item>
<item>
<title>필름 카피어</title>
<link>https://devage.tistory.com/14</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2005.03.22에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;slrclub에 올라온 사용기를 읽고, 난생 처음으로 ebay에서 물건을 하나 구입했다. 바로 Opteka 사의 필름 카피어(film copier)라고 하는 것으로, 배송료까지 다 합쳐도 10만원이 안돼서 가난한 자의 필름스캐너라고 할 수 있겠다. 아래 사진에서 렌즈 앞의 긴 경통과 사각형 부분이 필름 카피어이다.&lt;/p&gt;
&lt;p&gt;사용법은 간단해서, DSLR의 렌즈 앞부분에 필터 대신 필름 카피어를 연결하면 된다. 그리고 나서 카피어 앞부분에 슬라이드 마운트를 넣고, 마운트에 슬라이드 필름은 꽂은 다음 촛점 맞추고 노출을 측정한 후 '찍으면' 된다.&lt;/p&gt;
&lt;p&gt;나의 경우에는 D100에 45mm F2.8P 렌즈를 연결하고, 그 앞에 필름 카피어를 연결해서 사용했다. 슬라이드 필름의 내용을 화면 꽉 차게 넣기 위해서는 D100이나 D70 기준으로 60mm 화각의 렌즈가 적절할 것 같다. 다음은 필름 카피어를 이용해 슬라이드 필름을 찍은 결과물이다.&lt;/p&gt;
&lt;p&gt;(no photo)&lt;br /&gt;Opteka Film Copier + D100&lt;/p&gt;
&lt;p&gt;(no photo)&lt;br /&gt;Minolta Scan Elite 5400&lt;/p&gt;
&lt;p&gt;필름스캐너를 이용한 결과물과 비교해보면 카피어 쪽이 보다 쉽게 만족할 만한 결과물을 얻을 수 있었다. 스캐너 쪽은 색공간 변환을 포함해서 공을 많이 들여 후보정 작업을 해주어야 제대로 된 결과물을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;대신 계조 등의 표현범위는 스캐너 쪽이 더 우수했다. 예를 들어 윗 사진에서 창이나 현관 쪽은 조금만 어두워져도 윤곽을 확인하기 힘들 정도인데 반해, 스캐너 결과물은 현관문의 윤곽이라든가, 창 안쪽의 복도 모습까지 육안으로 비교적 쉽게 확인할 수 있었다.&lt;/p&gt;
&lt;p&gt;필름 카피어를 쓸 경우의 장점은 다음과 같이 정리할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가격이 필름 스캐너에 비해 무척 저렴하다.&lt;/li&gt;
&lt;li&gt;처음에 한 번 필름 카피어를 렌즈에 연결하고 촛점과 노출 설정하는 작업만 해두면 슬라이드 필름 당 작업 시간이 매우 짧다.&lt;/li&gt;
&lt;li&gt;슬라이드 필름을 찍은 결과물이 마음에 안들면 노출이나 화밸 설정을 바꾸어 얼마든지 여러 번 찍을 수 있다.&lt;/li&gt;
&lt;li&gt;후보정을 위한 작업량이 적다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;물론 단점도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;슬라이드에 마운트한 필름만 스캔할 수 있다. 롤 형태의 필름을 위한 홀더가 없다.&lt;/li&gt;
&lt;li&gt;수평 맞추기가 힘들다. 렌즈에 필터 끼우듯이 필름 카피어를 장착하는 방식이기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;필름 카피어 맞은 편에서 들어오는 빛의 종류에 따라 후보정에서 화밸을 맞춰줘야 한다. 그래서 본인의 경우에는 가급적 낮에 햇빛을 받으면서 작업한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전문가용으로는 힘들겠지만, 가성비 좋은 결과물을 얻을 수 있어서 웹 사진용 스캐너로 쓰기에 적당해 보인다.&lt;/p&gt;</description>
<category>사진</category>
<category>film</category>
<category>opteka</category>
<author>devage</author>
<guid>https://devage.tistory.com/14</guid>
<comments>https://devage.tistory.com/14#entry14comment</comments>
<pubDate>Tue, 20 Aug 2019 12:29:20 +0900</pubDate>
</item>
<item>
<title>Matin 4x 루페 사용기</title>
<link>https://devage.tistory.com/13</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2004.11.30에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;처음에 9,000원 짜리 니콘 10x 루페를 써보고 '역시 싼게 비지떡'이라는 결론을 내렸다. 그 후에도 슈나이더니 로덴스톡이니 하는 것들은 여전히 가격의 압박 때문에 쉽게 결정을 내리지 못했고, 한번 더 모험을 하기로 했다. 문제는 이제 호라이즌이냐 마틴이냐 하는 것이었는데, 마침 호라이즌에는 마땅히 살만한게 없었다. 4배 루페가 접이식이었는데 쉽게 망가질 것 같아 보여서, 결국 3만원대 마틴 4x 루페를 구입했다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/Uufck/btqxCOtDQ8M/eMIIM6s0OgIekDmdYYP5F0/img.jpg' data-lightbox='lightbox' data-alt='Matin 4x Loupe'&gt;&lt;img src='https://k.kakaocdn.net/dn/Uufck/btqxCOtDQ8M/eMIIM6s0OgIekDmdYYP5F0/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FUufck%2FbtqxCOtDQ8M%2FeMIIM6s0OgIekDmdYYP5F0%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Matin 4x Loupe&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;이번 결과는 대만족이다. 35mm 슬라이드 필름이 짤리는 부분 없이 한눈에 깨끗하게 보인다. 왜곡도 없고, 색수차도 보이지 않는다. 시도 보정 기능도 가지고 있어서 안경을 낀 채로도 볼 수 있다. 돌리는 부분이 좀 뻑뻑하긴 하지만 처음에 자신의 시력에 맞춰놓으면 잘 바꿀 일이 없다는 점을 생각하면 오히려 더 좋은게 아닌가 싶다.&lt;/p&gt;
&lt;p&gt;게다가 플라스틱 재질의 Nikon 루페와 달리 Matin 루페의 바디는 알루미늄 금속 재질이다. 루페를 잡을 때마다 느끼는 무게감과 차가운 감각은 사람에 따라 주관적으로 호불호가 갈릴 수 있지만 적어도 나한테는 장점이 되었다. 접안부 아래의 필름과 닿는 쪽은 플라스틱 재질의 반투명 스커트인데, 검은색 스커트도 같이 들어있어서 필요에 따라 교체할 수 있다. 하지만 눈의 위치가 루페 정중앙에서 조금만 벗어나도 바로 상이 흐려지는 점이 좀 불만이다. 되도록 시선을 필름면과 90도 직각이 되도록 유지해줘야 한다.&lt;/p&gt;
&lt;p&gt;사온 김에 Nikon 10x와 Matin 4x 루페의 왜곡 및 색수차 정도를 비교해보았다. 니콘 루페에 대한 사진도 이번에 다시 찍었다. 니콘 루페 때와 마찬가지로 A4 용지에 워드로 Times New Roman 11pt 영문 대문자로 알파벳을 반복해서 찍은 것을 이용했다.&lt;/p&gt;
&lt;h3 id=&quot;nikon-10x-&quot;&gt;Nikon 10x 루페의 경우&lt;/h3&gt;
&lt;p&gt;왜곡 면에서나 색수차 면에서나 지난 번에 보았던 것처럼 두드러져 보인다. 특히 중앙부 영역에서도 약간의 색수차를 보이고 있다. 'Z'의 윗부분 및 'B'의 우측 부분을 보면 알 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/LVe7N/btqxB6OOsgr/NkARtkCyQJmTNXep4qs751/img.jpg' data-lightbox='lightbox' data-alt='Nikon 10x의 왜곡'&gt;&lt;img src='https://k.kakaocdn.net/dn/LVe7N/btqxB6OOsgr/NkARtkCyQJmTNXep4qs751/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FLVe7N%2FbtqxB6OOsgr%2FNkARtkCyQJmTNXep4qs751%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Nikon 10x의 왜곡&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Nikon 10x를 통해 본 모습. 왜곡률이 꽤 크다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/lZuFL/btqxBPzLxNf/Gee7UjCUI8s6hiMXBxTO70/img.jpg' data-lightbox='lightbox' data-alt='Nikon 10x 중앙 영역'&gt;&lt;img src='https://k.kakaocdn.net/dn/lZuFL/btqxBPzLxNf/Gee7UjCUI8s6hiMXBxTO70/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FlZuFL%2FbtqxBPzLxNf%2FGee7UjCUI8s6hiMXBxTO70%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Nikon 10x 중앙 영역&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/baS258/btqxygSHeqt/SyNJnvPxIWztKKOdYldkPK/img.jpg' data-lightbox='lightbox' data-alt='Nikon 10x 좌상단 영역'&gt;&lt;img src='https://k.kakaocdn.net/dn/baS258/btqxygSHeqt/SyNJnvPxIWztKKOdYldkPK/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbaS258%2FbtqxygSHeqt%2FSyNJnvPxIWztKKOdYldkPK%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Nikon 10x 좌상단 영역&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위에부터 각각 중앙 영역, 좌상단 영역 확대 사진이다.&lt;/p&gt;
&lt;h3 id=&quot;matin-4x-&quot;&gt;Matin 4x 루페는&lt;/h3&gt;
&lt;p&gt;전체적으로 왜곡이라던가 색수차를 거의 볼 수 없었다. 대신 좌상단 영역에서는 'K' 문자에서 볼 수 있듯이 중앙 영역에 비해 선예도가 약간 떨어진다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/IkRPn/btqxDvAoXo0/0qiQFT1SBwPp9iRnyEaEqK/img.jpg' data-lightbox='lightbox' data-alt='Matin 4x 왜곡'&gt;&lt;img src='https://k.kakaocdn.net/dn/IkRPn/btqxDvAoXo0/0qiQFT1SBwPp9iRnyEaEqK/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FIkRPn%2FbtqxDvAoXo0%2F0qiQFT1SBwPp9iRnyEaEqK%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Matin 4x 왜곡&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(빨간색 가이드라인과 문자열의 각도 차이는 루페의 문제가 아니라 촬영자의 실수로, 이를 감안하여 봐주시기 바랍니다.)&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/c1NXm7/btqxyuJVq55/nXnkO3fwE4CAIxJT0B12a1/img.jpg' data-lightbox='lightbox' data-alt='Matin 4x 중앙 영역'&gt;&lt;img src='https://k.kakaocdn.net/dn/c1NXm7/btqxyuJVq55/nXnkO3fwE4CAIxJT0B12a1/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fc1NXm7%2FbtqxyuJVq55%2FnXnkO3fwE4CAIxJT0B12a1%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Matin 4x 중앙 영역&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cxXP19/btqxC59Kkly/kgqufRko8ESp2FVy5SkZn1/img.jpg' data-lightbox='lightbox' data-alt='Matin 4x 좌상단 영역'&gt;&lt;img src='https://k.kakaocdn.net/dn/cxXP19/btqxC59Kkly/kgqufRko8ESp2FVy5SkZn1/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FcxXP19%2FbtqxC59Kkly%2FkgqufRko8ESp2FVy5SkZn1%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Matin 4x 좌상단 영역&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;위에부터 각각 중앙 영역, 좌상단 영역 확대 사진이다.&lt;/p&gt;
&lt;p&gt;마지막으로 다음은 각 루페를 써서 실제 슬라이드 샘플을 본 것으로, 위에서부터 차례로 Nikon 10x, Matin 4x로 봤을 때의 모습이다. Nikon 10x의 경우 가로등을 보면 알 수 있듯이 가로로는 꽤 짤려나간다. 게다가 중앙에서조차도 색수차가 발생하기 때문에 구석의 내용을 제대로 보려면 그 부분을 가운데에서 볼 수 있도록 루페를 이동시켜줘야 한다. 결과적으로 전체 필름 내용을 다 제대로 보려면 루페를 이리저리 움직여줘야 한다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/Wgwwg/btqxAezPTr4/cSRnyP7ylBr5Eh4ululMik/img.jpg' data-lightbox='lightbox' data-alt='Nikon 10x View'&gt;&lt;img src='https://k.kakaocdn.net/dn/Wgwwg/btqxAezPTr4/cSRnyP7ylBr5Eh4ululMik/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FWgwwg%2FbtqxAezPTr4%2FcSRnyP7ylBr5Eh4ululMik%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Nikon 10x View&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/TNN0T/btqxDUfBRVB/WPmGxuMf5ziGaKzRpaRPs1/img.jpg' data-lightbox='lightbox' data-alt='Matin 4x View'&gt;&lt;img src='https://k.kakaocdn.net/dn/TNN0T/btqxDUfBRVB/WPmGxuMf5ziGaKzRpaRPs1/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FTNN0T%2FbtqxDUfBRVB%2FWPmGxuMf5ziGaKzRpaRPs1%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;Matin 4x View&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Matin 루페에 대해 총평을 내리자면 '로덴스톡이나 슈나이더의 1/4 가격으로도 왜곡이나 색수차 없이 필름을 한 눈에 깨끗하게 볼 수 있다' 정도로 정리할 수 있지 않을까. 여기에 렌즈의 정중앙이 아닌 부분에서도 필름을 깨끗하게 볼 수 있다면 정말로 10만원대 루페가 부럽지 않을 것이다.&lt;/p&gt;</description>
<category>사진</category>
<category>loupe</category>
<category>MATIN</category>
<author>devage</author>
<guid>https://devage.tistory.com/13</guid>
<comments>https://devage.tistory.com/13#entry13comment</comments>
<pubDate>Tue, 20 Aug 2019 12:28:06 +0900</pubDate>
</item>
<item>
<title>니콘 루페 사용기</title>
<link>https://devage.tistory.com/12</link>
<description>&lt;p&gt;&lt;span style=&quot;color: #818f9c;&quot;&gt;2004.11.08에 포스팅한 글입니다. 티스토리에 백업으로 옮기면서 포스팅 날짜가 바뀌었습니다.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;슬라이드 필름 현상을 맡기고 나서 이제 감상단계에 들어가니까 필요한게 한두 개가 아니다. 모든 필름을 인화한다는 것은 돈 속에서 헤엄칠 정도이거나 심장이 두 개인 사람이 아니면 하기 힘든 일이고, 조금이라도 돈을 절약하려면 필름을 보고 인화할 것을 걸러내야 하는데 이 역시 루페라든가 라이트박스 등 구비해야 할 것 때문에 돈 빠져나가는 것은 마찬가지다. 차이점이라면 후자는 초기에만 돈을 쓴다는 것 정도?&lt;/p&gt;
&lt;p&gt;그 중 쓸만한 루페에 대해서 인터넷을 검색해보면 슈나이더 4x이나 로덴스톡 4x이 나오는데 그 가격은 무려 12~14만원 대에 육박한다. 반면에 제일 값싼 니콘 루페 10x는 단돈 9,000원. 이 루페에 대해서는 그 가격으로 보나 사람들 의견으로 보나 '싼게 비지떡'이라는 옛말이 딱 맞아 떨어질 것으로 예상되지만, 어디에도 '과연 니콘 루페는 얼마나 안좋은가'에 대한 구체적인 설명을 찾을 수 없었다.&lt;/p&gt;
&lt;p&gt;다른 사람의 의견을 읽기만 하다가는 얼마큼 좋은지 나쁜지, 내 기준에도 과연 나쁜지 전혀 가늠할 수 없다. 그래서 나중에 다시 다른 루페를 사는 한이 있어도 '얼마큼 나쁜지 보기나 하자'란 생각에 샀다. 혹시 써봤더니 나름 대로 쓸만하더라, 하는 결론이 나오면 땡잡은 거 아닌가.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/dO8QvE/btqxB6uz6Ap/PbgVRaAUrQVYQ7aI4TPrR1/img.jpg' data-lightbox='lightbox' data-alt='니콘 루페 10x'&gt;&lt;img src='https://k.kakaocdn.net/dn/dO8QvE/btqxB6uz6Ap/PbgVRaAUrQVYQ7aI4TPrR1/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdO8QvE%2FbtqxB6uz6Ap%2FPbgVRaAUrQVYQ7aI4TPrR1%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;니콘 루페 10x&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;분해해보면 아래 그림과 같이 두 개의 볼록 렌즈로 구성되어 있다. 다른 루페의 구조에 대해서 알지 못하므로 단정하여 말할 수 없지만 생각 외로 비교적 단순한 구조로 보인다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/MTroh/btqxB7G1wov/AAUaCmVOM4qxWcWeLT723k/img.gif' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/MTroh/btqxB7G1wov/AAUaCmVOM4qxWcWeLT723k/img.gif' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FMTroh%2FbtqxB7G1wov%2FAAUaCmVOM4qxWcWeLT723k%2Fimg.gif' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;실험 방법은 전문적인 방법은 모르고 단순하게 하기로 해서, A4 용지에 워드로 10pt 대문자 알파벳을 연속으로 찍어서 이를 확인하는 방법으로 했다. 인터넷에서 언급하는 니콘 루페에 대한 평가는 크게 두 가지이다. 1) 왜곡이 심하다. 2) 색수차가 많이 발생한다.&lt;/p&gt;
&lt;p&gt;왜곡에 대해서는, 직접 눈으로 본 결과 주변부로 갈 수록 아래 사진에서처럼 심하게 발생하는 것을 볼 수 있었다. 붉은 색 라인은 루페의 경계면을 따라 그린 선이고 주황색은 좀더 중심부에 가까운 곳의 왜곡을 그린 선인데, 정중앙에서 조금만 벗어나도 바로 왜곡이 발생하는 것을 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/cvxu7x/btqxyLEDA2r/OB281lF6OFrhYAdevXBUAK/img.jpg' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/cvxu7x/btqxyLEDA2r/OB281lF6OFrhYAdevXBUAK/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fcvxu7x%2FbtqxyLEDA2r%2FOB281lF6OFrhYAdevXBUAK%2Fimg.jpg' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;아래 사진의 색수차 사진은 디카로 잘못 찍었는지 중심부에서 벗어나 있는데, 따로 자로 재본 결과 루페로 볼 수 있는 3.6 x 2.2cm 크기의 구역 중에서 가운데 가로세로 1 x 1cm 정도 내의 내용만 색수차 없이 내용을 확인할 수 있었다. 그 외의 부분은 루페를 이리저리 움직여서 색수차 없이 볼 수 있는 영역에 담아서 봐야 하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/byTiom/btqxB8sk7ws/kPwS67FDO7PrwuvFQgBxh0/img.jpg' data-lightbox='lightbox' data-alt=''&gt;&lt;img src='https://k.kakaocdn.net/dn/byTiom/btqxB8sk7ws/kPwS67FDO7PrwuvFQgBxh0/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbyTiom%2FbtqxB8sk7ws%2FkPwS67FDO7PrwuvFQgBxh0%2Fimg.jpg' &gt;&lt;/span&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;윗 사진에서 회색 박스는 색수차가 없거나 약간 있는 정도인 곳을 나타낸다. 주변부 및 중심에서 가까운 영역에서의 색수차 정도를 보기 위해 각각 파란색 박스 영역의 이미지를 따로 떼어서 아래에 올렸으며, 1:1 크롭핑한 것 외에 다른 이미지 처리는 하지 않았다. 위에서부터 각각 1. 중앙부 2. 중심 근처 이미지이다.&lt;/p&gt;
&lt;p&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/dknDD4/btqxyibQJ8Y/81Sui52KRwP3KfI9QTsGc0/img.jpg' data-lightbox='lightbox' data-alt='1. 주변부'&gt;&lt;img src='https://k.kakaocdn.net/dn/dknDD4/btqxyibQJ8Y/81Sui52KRwP3KfI9QTsGc0/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FdknDD4%2FbtqxyibQJ8Y%2F81Sui52KRwP3KfI9QTsGc0%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;1. 주변부&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure class='imageblock alignCenter'&gt;&lt;span data-url='https://k.kakaocdn.net/dn/9QJTA/btqxC7zIaI4/20fO7ZBkTamQoMN8FeMHmk/img.jpg' data-lightbox='lightbox' data-alt='2. 중심 근처'&gt;&lt;img src='https://k.kakaocdn.net/dn/9QJTA/btqxC7zIaI4/20fO7ZBkTamQoMN8FeMHmk/img.jpg' srcset='https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2F9QJTA%2FbtqxC7zIaI4%2F20fO7ZBkTamQoMN8FeMHmk%2Fimg.jpg' &gt;&lt;/span&gt;&lt;figcaption&gt;2. 중심 근처&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;이틀 정도 써본 결과 니콘 루페는 좁은 영역 내에서의 촛점 확인 정도로는 유용하다는 결론을 내렸다. 그러나 오랫동안 들여다보고 있으면 눈이 쉽게 피곤해져서 없던 색수차마저 생길 정도이다(&amp;hellip;). 색수차 및 왜곡만 고려하면, 슬라이드 필름을 현상하는 포토피아 1층의 코닥 루페가 훨씬 우수하다.&lt;/p&gt;
&lt;p&gt;하지만 10배 넘는 가격의 루페를 낼름 사기는 어려운 일이다. 직업 상 하루종일 필름을 루페로 들여다봐야 하는 경우가 아니라면&amp;hellip;&lt;/p&gt;</description>
<category>사진</category>
<category>loupe</category>
<category>Nikon</category>
<author>devage</author>
<guid>https://devage.tistory.com/12</guid>
<comments>https://devage.tistory.com/12#entry12comment</comments>
<pubDate>Tue, 20 Aug 2019 12:26:17 +0900</pubDate>
</item>
</channel>
</rss>